

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iconoclash</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
            color: #2c3e50;
        }

        .container {
            background: transparent;
            max-width: 1400px;
            margin: 0 auto;
            border-radius: 0;
            box-shadow: none;
            overflow: visible;
            padding: 20px 0;
        }
        
        h1 {
            font-size: 2.8rem;
            font-weight: 800;
            margin-bottom: 16px;
        }

        .tagline {
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            margin: 15px auto 20px;
            max-width: 800px;
            line-height: 1.4;
            text-align: center;
            opacity: 0.95;
        }

        /* HEADER STYLES */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: left;
            border-radius: 20px;
            margin: 0 auto 20px auto;
            max-width: 1400px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.06);
        }

        .header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

.header h1 {
    text-align: left;
    margin-bottom: 0; /* Remove bottom margin since it's now inline */
    flex: 1; /* Take up available space */
}

.header .demo-step {
    flex-shrink: 0; /* Prevent the button from shrinking */
    margin-left: 20px; /* Add some space from the title */
}

        /* Steps within header */
        .header .steps {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-top: 30px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }

        .header .step {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 10px 15px;
            text-align: center;
            transition: all 0.3s ease;
            height: 60px;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 12px;
        }

        .header .step:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }

        .header .step-number {
            background: rgba(255, 255, 255, 0.3);
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            flex-shrink: 0;
            margin-bottom: 0px;
        }

        .header .step-text {
            font-size: 1rem;
            color: white;
            font-weight: 700;
            margin: 0;
            line-height: 1.2;
        }

        /* Demo step styling within header */
.header .step.demo-step {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px; /* Match auth button padding */
    min-height: 36px; /* Match auth button height */
    background: rgba(255, 255, 255, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 14px;
    font-weight: 600;
    color: white;
    white-space: nowrap;
}

.header .step.demo-step:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.header .step-demo-icon {
    font-size: 16px; /* Simple emoji icon, no background circle */
    line-height: 1;
    flex-shrink: 0;
}

.header .step.demo-step .step-text {
    color: white;
    font-size: 14px;
    font-weight: 600;
    line-height: 1;
}

        /* SECTION CONTAINERS */
        .topics-container,
        .speaker-selection-main,
        .format-selection-main,
        .question-section-main,
        .start-discussion-section {
            background: white;
            border-radius: 20px;
            padding: 20px;
            margin: 0 auto 20px auto;
            max-width: 1400px;
            border: 2px solid #e9ecef;
            box-shadow: 0 8px 24px rgba(0,0,0,0.06);
        }

        /* TOPICS SECTION */
        .section-header {
            text-align: left;
            margin-bottom: 30px;
        }

        .section-header h3 {
            color: #2c3e50;
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 10px;
        }
        .topic-selection {
    width: 100%;
    max-width: none;
}

        .topic-types-streamlined {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 12px;
    margin: 0 0 30px 0;
    margin-left: auto;
    margin-right: auto;
}
@media (max-width: 768px) {
    .topic-types-streamlined {
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
        max-width: 600px;
    }
}

@media (max-width: 480px) {
    .topic-types-streamlined {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
    }
}

        .topic-type-slim {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border: 3px solid transparent;
    border-radius: 15px;
    padding: 10px 15px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    height: 60px;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    gap: 10px;
}
        .topic-type-slim:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.15);
            border-color: #667eea;
        }

        .topic-type-slim.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateY(-3px);
        }

        .topic-type-slim .topic-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        .topic-type-slim .topic-title {
            font-size: 1rem;
            font-weight: 700;
            margin: 0;
        }

        .topic-type-slim.selected .topic-title {
            color: white;
        }

        /* CUSTOM TOPIC */
        .custom-topic-section-simplified {
            margin: 0;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .topic-type.custom-topic-simple {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 3px solid transparent;
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            cursor: default;
            transition: all 0.3s ease;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .topic-title-with-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 15px;
            font-size: 1rem;
            font-weight: 800;
            color: #2c3e50;
        }

        .topic-icon-inline {
            font-size: 1rem;
            line-height: 1;
        }

        .custom-topic-section-main {
    background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%);
    border-radius: 12px;
    padding: 20px;
    margin: 10px 0;
    border: 2px solid #28a745;
    width: 100%;
}

.custom-topic-section-main h4 {
    color: #2e7d32;
    margin-bottom: 15px;
    text-align: center;
}

.custom-topic-input-container {
    display: flex;
    gap: 12px;
    align-items: center;
    margin-bottom: 15px;
    width: 100%;
}

.custom-topic-input-container input {
    flex: 1;
    padding: 12px 15px;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    font-size: 14px;
    transition: border-color 0.3s ease;
}

.custom-topic-input-container input:focus {
    outline: none;
    border-color: #28a745;
    box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.1);
}

.custom-topic-input-container button {
    background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    white-space: nowrap;
}

.custom-topic-input-container button:disabled {
    background: #e9ecef;
    color: #6c757d;
    cursor: not-allowed;
}

.custom-topic-input-container button:not(:disabled):hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
}


        .custom-input-area {
            width: 100%;
            max-width: 500px;
        }

        .custom-input-area textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: none;
            transition: all 0.3s ease;
            background: white;
            margin-bottom: 12px;
        }

        .custom-input-area textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .topic-action-button {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 10px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 14px;
            color: #6c757d;
        }

        .topic-action-button.ready {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            border-color: #28a745;
            color: white;
        }

        /* SPEAKER SECTION */
        .speaker-header {
            text-align: left;
            margin-bottom: 25px;
        }

        .speaker-header h3 {
            color: #2c3e50;
            font-size: 1.4rem;
            margin-bottom: 10px;
        }

        .speaker-header p {
            color: #6c757d;
            margin: 0;
        }

        .ai-suggestions-area {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 12px;
            border: 2px dashed #667eea;
        }

        .ai-suggestions-area h4 {
            color: #667eea;
            text-align: center;
            margin-bottom: 15px;
        }

        .ai-speakers-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
    margin: 20px 0;
    max-width: 1200px;
    margin-left: auto;
    margin-right: auto;
}

/* Responsive breakpoints for AI speakers grid */
@media (max-width: 1200px) {
    .ai-speakers-grid {
        grid-template-columns: repeat(3, 1fr);
        max-width: 900px;
    }
}

@media (max-width: 900px) {
    .ai-speakers-grid {
        grid-template-columns: repeat(2, 1fr);
        max-width: 600px;
    }
}

@media (max-width: 600px) {
    .ai-speakers-grid {
        grid-template-columns: 1fr;
        max-width: 400px;
    }
}

        .ai-speaker-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .ai-speaker-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
        }

        .ai-speaker-card.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #e3f2fd 0%, #e1f5fe 100%);
        }
        .ai-speaker-card .speaker-name {
    font-weight: bold;
    margin-bottom: 4px;
    font-size: 1.1em;
}

.ai-speaker-card .speaker-details {
    font-size: 0.9em;
    color: #666;
    margin-bottom: 8px;
}

        /* Other Speakers button styling */
        .other-speakers-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3) !important;
        }

        .other-speakers-button:active {
            transform: translateY(0);
        }

        .custom-speaker-section-main {
            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid #28a745;
        }

        .custom-speaker-section-main h4 {
            color: #2e7d32;
            margin-bottom: 15px;
            text-align: center;
        }

        .custom-speaker-input-container {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 15px;
        }

        .custom-speaker-input-container input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .custom-speaker-input-container button {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .custom-speaker-input-container button:disabled {
    background: #e9ecef;
    color: #6c757d;
    cursor: not-allowed;
    opacity: 1; /* Remove the extra opacity since the background color already provides the gray */
}

.custom-speaker-input-container button:disabled:hover {
    transform: none !important;
    box-shadow: none !important;
}

        .custom-speaker-tips {
            text-align: center;
        }

        .custom-speaker-tips p {
            margin: 0;
            color: #2e7d32;
            font-size: 14px;
        }

        .selected-speakers {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 10px 0;
            border-left: 4px solid #28a745;
        }

        .selected-speakers h4 {
            color: #2e7d32;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        /* FORMAT SECTION */
        .format-header {
            text-align: left;
            margin-bottom: 30px;
        }

        .format-header h3 {
            color: #2c3e50;
            font-size: 1.4rem;
            margin-bottom: 10px;
        }

        .format-header p {
            color: #6c757d;
            margin: 0;
        }

        .format-types-grid {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 12px;
}

@media (max-width: 1200px) {
    .format-types-grid {
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
    }
}

@media (max-width: 768px) {
    .format-types-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
    }
}

@media (max-width: 480px) {
    .format-types-grid {
        grid-template-columns: 1fr;
    }
}

        .format-type-small {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .format-type-small:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.15);
        }

        .format-type-small.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #e3f2fd 0%, #e1f5fe 100%);
        }

        .format-icon-small {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .format-info {
            flex: 1;
        }

        .format-title-small {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
            margin-bottom: 3px;
        }

        .format-desc-small {
            font-size: 0.75rem;
            color: #6c757d;
            line-height: 1.2;
        }

        .premium-badge {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: white;
            font-size: 0.65rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 6px;
            vertical-align: middle;
        }

        .premium-format {
            position: relative;
        }

        .premium-format:not(.selected)::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            pointer-events: none;
        }

        /* QUESTION SECTION */
        .question-header {
            text-align: left;
            margin-bottom: 30px;
        }

        .question-header h3 {
            color: #2c3e50;
            font-size: 1.4rem;
            margin-bottom: 10px;
        }

        .question-header p {
            color: #6c757d;
            margin: 0;
        }

        .question-input-area textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 16px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        .question-input-area textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* AI Suggestions Toggle */
.ai-suggestions-toggle {
    text-align: center;
    margin-bottom: 20px;
}

.ai-suggestions-toggle .question-mode-button {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 12px 24px;
    font-size: 16px;
    font-weight: 600;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
    display: inline-flex;
    flex-direction: row;
    align-items: center;
    gap: 8px;
    min-height: auto;
    min-width: auto;
}

.ai-suggestions-toggle .question-mode-button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
}

.ai-suggestions-toggle .question-mode-button:active {
    transform: translateY(0);
}

.ai-suggestions-toggle .question-mode-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Question Input Section (styled like custom topic/speaker sections) */
.question-input-section-main {
    background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%);
    border-radius: 12px;
    padding: 20px;
    margin: 10px 0;
    border: 2px solid #28a745;
    width: 100%; /* Ensure it matches the speaker section width */
}

.question-input-container {
    display: flex;
    flex-direction: column;
    gap: 12px;
    align-items: center;
    width: 100%;
    margin-bottom: 15px; /* Match the speaker section spacing */
}

.question-input-container textarea {
    width: 100%;
    padding: 12px 15px;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    font-size: 14px;
    font-family: inherit;
    resize: vertical;
    transition: border-color 0.3s ease;
    min-height: 80px; /* Reduced height */
}

.question-input-container textarea:focus {
    outline: none;
    border-color: #28a745;
    box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.1);
}

.question-input-container .start-button {
    background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
    color: white;
    padding: 12px 40px; /* Increased horizontal padding for wider button */
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 200px; /* Minimum width to ensure it's wide enough */
    white-space: nowrap; /* Prevent text wrapping */
}

.question-input-container .start-button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
}

.question-input-container .start-button:disabled {
    background: #e9ecef;
    color: #6c757d;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

        /* START BUTTON SECTION */
        .start-discussion-section {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #e3f2fd 0%, #e1f5fe 100%);
            border: 2px solid #2196f3;
        }

        .start-button {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            padding: 18px 40px;
            border: none;
            border-radius: 16px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s ease;
            box-shadow: 0 8px 24px rgba(76, 175, 80, 0.3);
        }

        .start-button:hover {
            transform: translateY(-4px);
            box-shadow: 0 16px 40px rgba(76, 175, 80, 0.4);
        }

        .start-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .start-help-text {
            margin-top: 10px;
            color: #6c757d;
            font-size: 14px;
        }


        /* Header styles */
        .header-right {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .usage-indicator {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .usage-indicator.low {
            background: rgba(255, 107, 107, 0.2);
            border-color: rgba(255, 107, 107, 0.3);
        }

        .support-email {
            color: rgba(255, 255, 255, 0.9);
            text-decoration: none;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .support-email:hover {
            color: white;
            text-decoration: underline;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .magic-demo-btn {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .magic-demo-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .upgrade-btn {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            border: none;
            color: white;
        }

        .upgrade-btn:hover {
            background: linear-gradient(135deg, #ffb300 0%, #fb8c00 100%);
        }


        /* DISCUSSION ARENA */
        .discussion-arena {
            display: none;
            background: #f8f9fa;
            border-radius: 20px;
            padding: 30px;
            margin: 0 auto 20px auto;
            min-height: 400px;
            border: 2px solid #e9ecef;
            box-shadow: 0 8px 24px rgba(0,0,0,0.06);
            max-width: 1400px; /* ← Add max-width to match other containers */
        }

        .discussion-controls {
            display: none;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 20px;
            padding: 30px;
            margin: 0 auto 20px auto; /* ← Update this too */
            text-align: left;
            border: 2px solid #e9ecef;
            box-shadow: 0 8px 24px rgba(0,0,0,0.06);
            max-width: 1400px; /* ← Add max-width */
        }

        /* RESPONSIVE DESIGN */
        @media (max-width: 768px) {
            .header,
            .topics-container,
            .speaker-selection-main,
            .format-selection-main,
            .question-section-main,
            .start-discussion-section,
            .discussion-arena,
            .discussion-controls {
                margin: 0 20px 30px 20px;
                padding: 25px 20px;
            }
            
            .footer-nav {
                margin: 0 20px 0 20px;
                padding: 15px 20px;
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .footer-links {
                justify-content: center;
            }

            .header .steps {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
                margin-top: 25px;
            }
            
            /* Responsive header adjustments */
            .header-row {
                flex-direction: column;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 1.8rem;
                text-align: center;
            }
            
            .header-right {
                width: 100%;
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
            }
            
            .support-email {
                font-size: 13px;
            }
            
            .header-controls {
                width: 100%;
                justify-content: center;
            }
            
            .magic-demo-btn,
            .auth-btn {
                font-size: 14px;
                padding: 8px 16px;
            }
            
            .header .step {
                min-height: 90px;
                padding: 15px 10px;
            }
            
            .header .step-number,
            .header .step-demo-icon {
                width: 28px;
                height: 28px;
                font-size: 14px;
                margin-bottom: 6px;
            }
            
            .header .step-text {
                font-size: 0.9rem;
            }

            .topic-types-streamlined {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
                max-width: 500px;
            }
            
            .topic-type-slim {
                min-height: 90px;
                padding: 15px 10px;
            }
            
            .topic-type-slim .topic-icon {
                font-size: 1.8rem;
                margin-bottom: 6px;
            }
            
            .topic-type-slim .topic-title {
                font-size: 0.9rem;
            }

            .format-types-grid {
                grid-template-columns: 1fr;
            }
            
            .format-type-small {
                padding: 12px;
                gap: 12px;
            }

            .custom-speaker-input-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .custom-speaker-input-container button {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .header,
            .topics-container,
            .speaker-selection-main,
            .format-selection-main,
            .question-section-main,
            .start-discussion-section,
            .discussion-arena,
            .discussion-controls {
                margin: 0 15px 25px 15px;
                padding: 20px 15px;
            }
            
            .footer-nav {
                margin: 0 15px 0 15px;
                padding: 15px;
            }
            
            .footer-links {
                flex-direction: column;
                gap: 10px;
            }

            .header .steps {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                margin-top: 20px;
            }
            
            .header .step {
                min-height: 80px;
                padding: 12px 8px;
            }
            
            .header .step-number,
            .header .step-demo-icon {
                width: 26px;
                height: 26px;
                font-size: 13px;
            }
            
            .header .step-text {
                font-size: 0.85rem;
            }

            .topic-types-streamlined {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            
            .topic-type-slim {
                min-height: 80px;
                padding: 12px 8px;
            }
            
            .topic-type-slim .topic-icon {
                font-size: 1.6rem;
            }
            
            .topic-type-slim .topic-title {
                font-size: 0.85rem;
            }
        }
       

/* Manual Question Section */
.manual-question-section textarea {
    width: 100%;
    padding: 15px;
    border: 2px solid #e9ecef;
    border-radius: 10px;
    font-size: 16px;
    font-family: inherit;
    resize: vertical;
    transition: border-color 0.3s ease;
}

.manual-question-section textarea:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

/* Controls section */
.controls {
    text-align: center;
    margin-top: 30px;
}

.discussion-controls.active {
    display: block;
}

.controls-header {
    font-size: 1.3rem;
    font-weight: 700;
    color: #2c3e50;
    margin-bottom: 20px;
}

.controls-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    align-items: center;
}

.control-button {
    padding: 16px 24px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.control-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.15);
}

.control-button.continue-button {
    background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    color: white;
}

.control-button.share-button {
    background: linear-gradient(135deg, #1da1f2 0%, #0d8bd9 100%);
    color: white;
}

.control-button.save-button {
    background: linear-gradient(135deg, #ffc107 0%, #ff8f00 100%);
    color: #333;
}

.control-button.new-button {
    background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
    color: white;
}

/* Mobile responsive */
@media (max-width: 768px) {
    .controls-buttons {
        flex-direction: column;
        width: 100%;
    }
    
    .control-button {
        width: 100%;
        max-width: 280px;
    }
}

.start-button {
    background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
    color: white;
    padding: 18px 40px;
    border: none;
    border-radius: 16px;
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.4s ease;
    box-shadow: 0 8px 24px rgba(76, 175, 80, 0.3);
}

.start-button:hover {
    transform: translateY(-4px);
    box-shadow: 0 16px 40px rgba(76, 175, 80, 0.4);
}

.start-button:disabled {
    background: #ccc;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}
.suggested-questions {
    display: grid;
    gap: 15px; /* Increase gap between questions */
    margin-top: 20px;
}

.question-suggestion {
    background: white;
    padding: 20px; /* More padding for better spacing */
    border-radius: 12px;
    border: 2px solid #e9ecef; /* Visible border */
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08); /* More prominent shadow */
    position: relative;
}

.question-suggestion:hover {
    border-color: #2196F3;
    transform: translateY(-3px); /* More noticeable lift */
    box-shadow: 0 8px 25px rgba(33, 150, 243, 0.2);
    background: #f8f9ff; /* Slight background change on hover */
}

.question-suggestion.selected {
    border-color: #2196F3;
    background: linear-gradient(135deg, #e3f2fd 0%, #e1f5fe 100%);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(33, 150, 243, 0.15);
}

/* Add a click indicator */
/* Remove the click indicators */
.question-suggestion::before {
    display: none;
}

.question-suggestion:hover::before {
    display: none;
}

.question-suggestion.selected::before {
    display: none;
}

.question-text {
    font-weight: 700; /* Bolder text */
    color: #2c3e50;
    margin-bottom: 10px; /* More space between question and explanation */
    line-height: 1.4;
    font-size: 1.1rem; /* Slightly larger */
    padding-right: 40px; /* Space for the icon */
}

.question-explanation {
    font-size: 0.95rem;
    color: #6c757d;
    line-height: 1.5;
    font-style: italic;
    padding-left: 10px;
    border-left: 3px solid #e9ecef; /* Visual separator */
}

.question-suggestion:hover .question-explanation {
    border-left-color: #2196F3; /* Change separator color on hover */
}

/* Add a subtle "click to select" hint */
.suggestion-header::after {
    content: "💡 Click any question below to select it";
    display: block;
    font-size: 0.9rem;
    color: #6c757d;
    font-style: italic;
    margin-top: 10px;
    text-align: center;
}
.speaker-content {
            line-height: 1.6;
            color: #2c3e50;
        }
        
        .speaker-content p {
            margin-bottom: 15px;
            line-height: 1.7;
        }
        
        .speaker-content p:last-child {
            margin-bottom: 0;
        }
        
        .speaker-content h4 {
            color: #495057;
            font-size: 1.05rem;
            font-weight: 600;
            margin: 20px 0 10px 0;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 5px;
        }
        
        .speaker-content h4:first-child {
            margin-top: 0;
        }
        
        .speaker-content ul, .speaker-content ol {
            margin: 15px 0;
            padding-left: 25px;
        }
        
        .speaker-content li {
            margin-bottom: 8px;
            line-height: 1.6;
        }
        
        .speaker-content blockquote {
            border-left: 4px solid #667eea;
            padding-left: 20px;
            margin: 20px 0;
            font-style: italic;
            color: #5a6c7d;
        }

        /* SPEAKER TILES - COMPLETE STYLING */
        .speaker {
            margin: 20px 0;
            padding: 25px;
            border-radius: 16px;
            border-left: 5px solid #667eea;
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
            background: white;
            border: 1px solid rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .speaker:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 30px rgba(0,0,0,0.12);
        }
        
        .speaker::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea 0%, transparent 100%);
        }
        
        .speaker-name {
            font-weight: 700;
            margin-bottom: 15px;
            font-size: 1.15rem;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #2c3e50;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(0,0,0,0.05);
        }
        
        .speaker-name::before {
            content: '💬';
            font-size: 1.2rem;
        }
        
        /* Speaker 1 - Blue */
.speaker.speaker-1 {
    border-left-color: #667eea;
    background: linear-gradient(135deg, #f8faff 0%, #e3f2fd 100%);
}

.speaker.speaker-1::before {
    background: linear-gradient(90deg, #667eea 0%, transparent 100%);
}

/* Speaker 2 - Purple */
.speaker.speaker-2 {
    border-left-color: #764ba2;
    background: linear-gradient(135deg, #faf8ff 0%, #f3e5f5 100%);
}

.speaker.speaker-2::before {
    background: linear-gradient(90deg, #764ba2 0%, transparent 100%);
}

/* Speaker 3 - Teal */
.speaker.speaker-3 {
    border-left-color: #20c997;
    background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
}

.speaker.speaker-3::before {
    background: linear-gradient(90deg, #20c997 0%, transparent 100%);
}

/* Speaker 4 - Orange */
.speaker.speaker-4 {
    border-left-color: #fd7e14;
    background: linear-gradient(135deg, #fff8f0 0%, #fed7aa 100%);
}

.speaker.speaker-4::before {
    background: linear-gradient(90deg, #fd7e14 0%, transparent 100%);
}

/* Speaker 5 - Pink */
.speaker.speaker-5 {
    border-left-color: #e83e8c;
    background: linear-gradient(135deg, #fdf2f8 0%, #fce7f3 100%);
}

.speaker.speaker-5::before {
    background: linear-gradient(90deg, #e83e8c 0%, transparent 100%);
}

/* Speaker 6 - Indigo */
.speaker.speaker-6 {
    border-left-color: #6610f2;
    background: linear-gradient(135deg, #f8f7ff 0%, #ede9fe 100%);
}

.speaker.speaker-6::before {
    background: linear-gradient(90deg, #6610f2 0%, transparent 100%);
}
        
        .moderator-speaker {
            border-left-color: #ff9800 !important;
            background: linear-gradient(135deg, #fffbf0 0%, #fff3e0 100%) !important;
            border: 2px solid rgba(255, 152, 0, 0.2) !important;
        }
        
        .moderator-speaker::before {
            background: linear-gradient(90deg, #ff9800 0%, transparent 100%) !important;
        }
        
        
        .user-speaker {
            border-left-color: #28a745 !important;
            background: linear-gradient(135deg, #f8fff9 0%, #e8f5e8 100%) !important;
            border: 2px solid rgba(40, 167, 69, 0.2) !important;
        }
        
        .user-speaker::before {
            background: linear-gradient(90deg, #28a745 0%, transparent 100%) !important;
        }
        
        .user-speaker .speaker-name::before {
            content: '👤';
        }
        
        /* Discussion round and phase styling */
        .discussion-round {
            background: linear-gradient(135deg, #fafbfc 0%, #f0f2f5 100%);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.06);
        }
        
        .round-header {
            font-weight: 700;
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.2rem;
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }
        
        .phase-indicator {
            font-weight: 600;
            color: #764ba2;
            text-align: center;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            padding: 8px 16px;
            background: linear-gradient(135deg, #faf5ff 0%, #f3e7fc 100%);
            border-radius: 20px;
            display: inline-block;
            width: 100%;
            box-shadow: 0 2px 6px rgba(118, 75, 162, 0.1);
        }
         /* CONVERSATION BRANCHING STYLES */
        .speaker-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 12px;
            border-top: 1px solid rgba(0,0,0,0.1);
            gap: 10px;
        }

        .interject-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .interject-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }

        .branch-container {
            margin-left: 30px;
            margin-top: 20px;
            padding-left: 20px;
            border-left: 3px solid #667eea;
            position: relative;
        }

        .branch-container::before {
            content: '🌿';
            position: absolute;
            left: -12px;
            top: -5px;
            background: white;
            padding: 2px;
            border-radius: 50%;
            font-size: 16px;
        }

        .user-interjection {
            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%) !important;
            border-left-color: #28a745 !important;
            border: 2px solid rgba(40, 167, 69, 0.3) !important;
            margin-bottom: 15px;
        }

        .user-interjection::before {
            background: linear-gradient(90deg, #28a745 0%, transparent 100%) !important;
        }

        .user-interjection .speaker-name::before {
            content: '🙋';
        }

        .interjection-input {
            background: rgba(102, 126, 234, 0.05);
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
        }

        .interjection-input textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            min-height: 80px;
            margin-bottom: 12px;
        }

        .interjection-input textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .interjection-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .interjection-submit {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .interjection-cancel {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .interjection-submit:hover,
        .interjection-cancel:hover {
            transform: translateY(-2px);
        }

        .branch-return {
            margin: 20px 0;
            text-align: center;
        }

        .return-btn {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            border: 2px solid #667eea;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .return-btn:hover {
            background: #667eea;
            color: white;
        }

        .context-indicator {
            background: rgba(102, 126, 234, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #667eea;
            font-style: italic;
        }

        /* User Response Input Styles */
        .user-response-input {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .user-input-header {
            margin-bottom: 15px;
        }

        .user-input-header h4 {
            color: #2c3e50;
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0;
        }

        #userChatResponse {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s ease;
            margin-bottom: 15px;
        }

        #userChatResponse:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        #userChatResponse::placeholder {
            color: #adb5bd;
        }

        .user-input-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .user-input-actions button {
            padding: 10px 24px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .user-input-actions button:first-child {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .user-input-actions button:first-child:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .user-input-actions button:disabled {
            background: #e9ecef;
            color: #adb5bd;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .user-input-actions button:last-child {
            background: #e9ecef;
            color: #6c757d;
        }

        .user-input-actions button:last-child:hover {
            background: #dee2e6;
        }

        .user-speaker {
            background: #f0f7ff;
            border-left: 4px solid #2196f3;
        }

        .user-speaker .speaker-name {
            color: #2196f3;
        }

        /* Chat continuation styles */
        .chat-continuation-container {
            margin-top: 20px;
        }

        .chat-controls {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
        }

        .chat-controls .controls-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .chat-controls .control-button {
            padding: 10px 20px;
            font-size: 14px;
        }

        /* Mobile responsiveness for branching */
        @media (max-width: 768px) {
            .branch-container {
                margin-left: 15px;
                padding-left: 15px;
            }
            
            .speaker-actions {
                flex-direction: column;
                gap: 8px;
            }
            
            .interject-btn {
                width: 100%;
                justify-content: center;
            }
            
            .user-response-input {
                padding: 20px 15px;
            }
            
            .user-input-actions {
                flex-direction: column;
            }
            
            .user-input-actions button {
                width: 100%;
            }
            
            .chat-controls .controls-buttons {
                flex-direction: column;
            }
            
            .chat-controls .control-button {
                width: 100%;
            }
        }
        .question-mode-toggle {
    display: flex;
    gap: 15px;
    margin-bottom: 30px;
    justify-content: center;
}

.question-mode-button {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border: 3px solid transparent;
    border-radius: 15px;
    padding: 20px 30px;
    cursor: pointer;
    transition: all 0.3s ease;
    min-height: 80px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 8px;
    font-weight: 700;
    font-size: 1rem;
    color: #2c3e50;
    min-width: 200px;
}

.question-mode-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.15);
    border-color: #667eea;
}

.question-mode-button.active {
    border-color: #667eea;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    transform: translateY(-2px);
}
/* Auth Modal Styles */
.auth-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.auth-modal.show {
    display: flex;
}

.auth-content {
    background: white;
    padding: 40px;
    border-radius: 20px;
    width: 90%;
    max-width: 400px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    position: relative;
}

.auth-close {
    position: absolute;
    top: 15px;
    right: 20px;
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #999;
}

.auth-close:hover {
    color: #333;
}

.auth-header {
    text-align: center;
    margin-bottom: 30px;
}

.auth-header h2 {
    color: #2c3e50;
    margin-bottom: 10px;
}

.auth-form {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.auth-input {
    padding: 15px;
    border: 2px solid #e9ecef;
    border-radius: 10px;
    font-size: 16px;
    transition: border-color 0.3s ease;
}

.auth-input:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.auth-submit {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 15px;
    border: none;
    border-radius: 10px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.auth-submit:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
}

.auth-submit:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

.auth-toggle {
    text-align: center;
    margin-top: 20px;
    color: #6c757d;
}

.auth-toggle a {
    color: #667eea;
    text-decoration: none;
    font-weight: 600;
}

.auth-toggle a:hover {
    text-decoration: underline;
}

.auth-error {
    background: #f8d7da;
    color: #721c24;
    padding: 10px 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    display: none;
}

.auth-success {
    background: #d4edda;
    color: #155724;
    padding: 10px 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    display: none;
}

/* Update header auth section */
.auth-section {
    display: flex;
    align-items: center;
}

.auth-buttons {
    display: flex;
    align-items: center;
    gap: 10px;
}

.auth-btn {
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-block;
}

.auth-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-1px);
    text-decoration: none;
}

.user-menu {
    display: flex;
    align-items: center;
    gap: 12px;
}

.user-welcome {
    font-size: 14px;
    opacity: 0.9;
}

/* Responsive adjustments */
@media (max-width: 1024px) {
    .header-right {
        gap: 8px;
    }
    
    .auth-btn, .step.demo-step {
        padding: 6px 12px;
        min-height: 32px;
        font-size: 13px;
    }
    
    .step-demo-icon {
        font-size: 14px;
    }
}

@media (max-width: 768px) {
    .header-row {
        flex-direction: column;
        gap: 15px;
    }
    
    .header-right {
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
        gap: 10px;
    }
    
    .nav-links {
        order: -1;
        margin-right: 0;
    }
    
    .auth-buttons {
        gap: 8px;
    }
}

@media (max-width: 480px) {
    .header-right {
        flex-direction: column;
        gap: 12px;
    }
    
    .auth-buttons {
        width: 100%;
        justify-content: center;
    }
    
    .step.demo-step {
        width: auto;
    }
}
        .header .step.demo-step {
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.4);
            cursor: pointer;
        }        .header .step.demo-step:hover {
            background: rgba(255, 255, 255, 0.35);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
        }        .header .step-demo-icon {
            background: rgba(255, 255, 255, 0.3);
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            flex-shrink: 0;
            margin-bottom: 8px;
        }        .header .step.demo-step .step-text {
            color: white;
        }
.header .step.demo-step {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px; /* Match auth button padding */
    min-height: 36px; /* Match auth button height */
    background: rgba(255, 255, 255, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 14px;
    font-weight: 600;
    color: white;
    white-space: nowrap;
}

.header .step.demo-step:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.header .step-demo-icon {
    font-size: 16px; /* Simple emoji icon, no background circle */
    line-height: 1;
    flex-shrink: 0;
}

.header .step.demo-step .step-text {
    color: white;
    font-size: 14px;
    font-weight: 600;
    line-height: 1;
}

.auth-btn {
    padding: 8px 16px;
    min-height: 36px;
    font-size: 14px;
    font-weight: 600;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    white-space: nowrap;
}

/* Fix header spacing */
.header-right {
    display: flex;
    align-items: center;
    gap: 12px;
}

.signup-prompt-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.signup-prompt-content {
    background: white;
    padding: 40px;
    border-radius: 20px;
    width: 90%;
    max-width: 500px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    text-align: center;
    color: #2c3e50;
}

.signup-prompt-content h2 {
    color: #2c3e50;
    margin-bottom: 15px;
    font-size: 1.8rem;
}

.signup-prompt-content p {
    color: #6c757d;
    margin-bottom: 20px;
    font-size: 1.1rem;
}

.signup-prompt-content ul {
    color: #2c3e50;
}

.signup-prompt-content li {
    margin-bottom: 8px;
}

.conversations-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.conversations-content {
    background: white;
    border-radius: 20px;
    padding: 30px;
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
    color: #2c3e50;
    width: 90%;
}

.conversations-header {
    border-bottom: 2px solid #e9ecef;
    padding-bottom: 15px;
    margin-bottom: 25px;
}

.conversation-item {
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 15px;
}

.conversation-title {
    font-weight: 600;
    font-size: 1.1rem;
    margin-bottom: 8px;
    color: #2c3e50;
}

.conversation-meta {
    color: #6c757d;
    font-size: 0.9rem;
    margin-bottom: 15px;
}

.shared-indicator {
    background: #28a745;
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.8rem;
    margin-left: 10px;
}

.conversation-actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.view-btn, .share-btn, .delete-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.view-btn {
    background: #667eea;
    color: white;
}

.share-btn {
    background: #28a745;
    color: white;
}

.delete-btn {
    background: #dc3545;
    color: white;
}

.view-btn:hover, .share-btn:hover, .delete-btn:hover {
    transform: translateY(-2px);
    opacity: 0.9;
}

@media (max-width: 768px) {
    .conversations-content {
        width: 95%;
        padding: 20px;
        max-height: 90vh;
    }
    
    .conversation-actions {
        flex-direction: column;
    }
    
    .view-btn, .share-btn, .delete-btn {
        width: 100%;
    }
}

/* Conversations Modal */
.conversations-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.conversations-content {
    background: white;
    border-radius: 20px;
    width: 90%;
    max-width: 800px;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 20px 40px rgba(0,0,0,0.3);
}

.conversations-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px 30px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.close-conversations {
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.conversations-list {
    max-height: 60vh;
    overflow-y: auto;
    padding: 20px;
}

.conversation-item {
    border: 2px solid #e9ecef;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: all 0.3s ease;
}

.conversation-item:hover {
    border-color: #667eea;
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
}

.conversation-main {
    flex: 1;
}

.conversation-title {
    font-size: 1.2rem;
    font-weight: 700;
    color: #2c3e50;
    margin-bottom: 8px;
}

.conversation-meta {
    display: flex;
    gap: 15px;
    margin-bottom: 8px;
    font-size: 0.9rem;
    color: #6c757d;
}

.conversation-topic {
    font-style: italic;
    color: #495057;
    font-size: 0.95rem;
}

.conversation-actions {
    display: flex;
    gap: 10px;
    flex-shrink: 0;
}

.action-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 8px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.view-btn {
    background: #28a745;
    color: white;
}

.share-btn {
    background: #17a2b8;
    color: white;
}

.delete-btn {
    background: #dc3545;
    color: white;
}

.action-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.no-conversations {
    text-align: center;
    padding: 40px;
    color: #6c757d;
}

.conversations-footer {
    padding: 20px;
    text-align: center;
    border-top: 1px solid #e9ecef;
}

.conversations-close-btn {
    background: #6c757d;
    color: white;
    padding: 12px 30px;
    border: none;
    border-radius: 10px;
    font-weight: 600;
    cursor: pointer;
}

/* Conversation Viewer */
.conversation-viewer {
    background: white;
    border-radius: 20px;
    margin: 20px 0;
    overflow: hidden;
    box-shadow: 0 8px 24px rgba(0,0,0,0.1);
}

.viewer-header {
    background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    color: white;
    padding: 25px 30px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.viewer-title h2 {
    margin-bottom: 8px;
}

.viewer-meta {
    display: flex;
    gap: 20px;
    font-size: 0.9rem;
    opacity: 0.9;
}

.viewer-actions {
    display: flex;
    gap: 15px;
}

.viewer-btn {
    background: rgba(255,255,255,0.2);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.viewer-btn:hover {
    background: rgba(255,255,255,0.3);
}

.viewer-content {
    padding: 30px;
}

@media (max-width: 768px) {
    .conversation-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 15px;
    }
    
    .conversation-actions {
        width: 100%;
        justify-content: flex-end;
    }
    
    .viewer-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 15px;
    }
}

/* ============================================================================
   COMPREHENSIVE MOBILE OPTIMIZATION
   ============================================================================ */

/* Mobile-first approach - enhance touch targets and usability */
@media (max-width: 768px) {
    /* Body and container adjustments */
    body {
        padding: 10px;
    }
    
    .container {
        padding: 10px 0;
    }
    
    /* Header mobile optimization */
    .header {
        padding: 15px;
        margin-bottom: 15px;
    }
    
    .header-row {
        flex-direction: column;
        gap: 15px;
    }
    
    .header h1 {
        font-size: 2rem;
        text-align: center;
        margin-bottom: 10px;
    }
    
    .header-right {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .usage-indicator {
        text-align: center;
        margin-bottom: 10px;
    }
    
    .support-email {
        text-align: center;
        margin-bottom: 10px;
    }
    
    .header-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
    }
    
    .auth-btn, .magic-demo-btn {
        min-height: 44px; /* Accessibility: minimum touch target */
        padding: 12px 16px;
        font-size: 14px;
        flex: 1;
        min-width: 120px;
    }
    
    /* Topic selection mobile */
    .topic-types-streamlined {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
    }
    
    .topic-type-slim {
        padding: 15px 10px;
        min-height: 80px;
    }
    
    .format-icon-small {
        font-size: 1.8rem;
    }
    
    .topic-title {
        font-size: 0.9rem;
    }
    
    /* Custom topic input mobile */
    .custom-topic-input-container {
        flex-direction: column;
        gap: 10px;
    }
    
    #customTopicInput {
        width: 100%;
        font-size: 16px; /* Prevent zoom on iOS */
    }
    
    #addCustomTopicBtn {
        width: 100%;
        min-height: 44px;
    }
    
    /* Speaker selection mobile */
    .ai-speakers-grid {
        grid-template-columns: 1fr;
        gap: 10px;
    }
    
    .ai-speaker-item {
        padding: 15px;
        min-height: 60px;
    }
    
    .custom-speaker-input-container {
        flex-direction: column;
        gap: 10px;
    }
    
    #customSpeakerInput {
        width: 100%;
        font-size: 16px; /* Prevent zoom on iOS */
    }
    
    #addCustomSpeakerBtn {
        width: 100%;
        min-height: 44px;
    }
    
    /* Format selection mobile */
    .format-types-grid {
        grid-template-columns: 1fr;
        gap: 10px;
    }
    
    .format-type-small {
        padding: 15px;
        min-height: 80px;
    }
    
    /* Question section mobile */
    .question-input-container {
        flex-direction: column;
        gap: 10px;
    }
    
    #userQuestionInput {
        width: 100%;
        min-height: 100px;
        font-size: 16px; /* Prevent zoom on iOS */
    }
    
    .start-button {
        width: 100%;
        min-height: 50px;
        font-size: 16px;
    }
    
    /* Discussion arena mobile */
    .discussion-arena {
        padding: 15px;
    }
    
    .discussion-response {
        padding: 15px;
    }
    
    .speaker-name {
        font-size: 1.1rem;
    }
    
    .response-text {
        font-size: 15px;
        line-height: 1.6;
    }
    
    /* Chat continuation mobile */
    .chat-continuation-container {
        padding: 15px;
    }
    
    .chat-input-container {
        flex-direction: column;
        gap: 10px;
    }
    
    #chatContinuationInput {
        font-size: 16px; /* Prevent zoom on iOS */
        min-height: 60px;
    }
    
    /* Discussion controls mobile */
    .discussion-controls {
        padding: 15px;
        gap: 10px;
    }
    
    .control-button {
        min-height: 44px;
        font-size: 14px;
        padding: 12px 16px;
        flex: 1;
    }
    
    /* Modal mobile optimization */
    .auth-content,
    .upgrade-content {
        width: 95%;
        padding: 20px;
        margin: 10px;
    }
    
    .auth-input {
        font-size: 16px; /* Prevent zoom on iOS */
        min-height: 44px;
    }
    
    .auth-submit {
        min-height: 44px;
        font-size: 16px;
    }
    
    /* Share functionality mobile */
    .share-button {
        min-height: 44px;
        width: 100%;
    }
}

/* Small mobile devices */
@media (max-width: 480px) {
    .header h1 {
        font-size: 1.5rem;
    }
    
    .topic-types-streamlined {
        grid-template-columns: 1fr;
    }
    
    .auth-btn, .magic-demo-btn {
        font-size: 13px;
        padding: 10px 12px;
    }
    
    .format-icon-small {
        font-size: 1.5rem;
    }
    
    .discussion-response {
        padding: 12px;
    }
    
    .speaker-name {
        font-size: 1rem;
    }
    
    .response-text {
        font-size: 14px;
    }
}

/* Landscape mobile optimization */
@media (max-width: 768px) and (orientation: landscape) {
    .header {
        padding: 10px 15px;
    }
    
    .header h1 {
        font-size: 1.8rem;
    }
    
    .topic-types-streamlined {
        grid-template-columns: repeat(3, 1fr);
    }
    
    .format-types-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}

/* Ensure all interactive elements have proper touch targets */
@media (hover: none) and (pointer: coarse) {
    /* Touch device optimizations */
    button, .button, .btn, 
    .auth-btn, .control-button, 
    .start-button, .magic-demo-btn,
    .share-button, .save-button,
    .interject-btn, .share-quote-btn {
        min-height: 44px;
        min-width: 44px;
        padding: 12px 16px;
    }
    
    /* Increase clickable area for small buttons */
    .speaker-actions button {
        padding: 8px 12px;
        min-height: 36px;
    }
    
    /* Better spacing for touch interactions */
    .format-types-grid,
    .topic-types-streamlined {
        gap: 12px;
    }
    
    /* Ensure text inputs are touch-friendly */
    input[type="text"],
    input[type="email"],
    input[type="password"],
    textarea {
        min-height: 44px;
        font-size: 16px;
        padding: 12px;
    }
    
    /* Better touch targets for links */
    a {
        display: inline-block;
        min-height: 44px;
        line-height: 44px;
        padding: 0 8px;
    }
    
    /* Ensure modals are touch-friendly */
    .modal-content,
    .auth-content,
    .upgrade-content {
        max-height: 90vh;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }
}

/* Mobile notification styles */
@media (max-width: 768px) {
    .notification {
        left: 10px;
        right: 10px;
        bottom: 20px;
        width: auto;
        font-size: 14px;
        padding: 12px 16px;
        text-align: center;
    }
}

/* Smooth scrolling for mobile */
@media (max-width: 768px) {
    html {
        scroll-behavior: smooth;
        -webkit-overflow-scrolling: touch;
    }
    
    /* Prevent horizontal scroll on mobile */
    body {
        overflow-x: hidden;
    }
    
    .container {
        overflow-x: hidden;
    }
}

        /* Upgrade Modal Styles */
        .upgrade-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .upgrade-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .upgrade-content h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 28px;
        }

        .upgrade-content p {
            color: #6c757d;
            font-size: 18px;
            margin-bottom: 30px;
        }

    </style>
</head>
<body>
    <div class="container">
      <!-- HEADER -->
<div class="header">
    <div class="header-row">
        <h1>📖 Iconoclash</h1>
        <div class="header-right">
            <!-- Usage indicator (always visible) -->
            <div class="usage-indicator" id="usageIndicator">
                <span id="usageCount">10 free today</span>
            </div>
            
            <!-- Support email -->
            <a href="mailto:hello@iconoclash.ai" class="support-email">hello@iconoclash.ai</a>
            
            <!-- Anonymous user controls -->
            <div class="header-controls" id="anonymousControls">
                <button class="magic-demo-btn" onclick="startMagicDemo('innovation')">
                    ✨ Magic Demo
                </button>
                <a href="#" class="auth-btn" onclick="checkProAccessForConversations(); return false;">📚 My Conversations</a>
                <button class="auth-btn upgrade-btn" onclick="showUpgradeModal()">⭐ Upgrade $2/mo</button>
            </div>
            
            <!-- Free user controls -->
            <div class="header-controls" id="freeUserControls" style="display: none;">
                <button class="auth-btn upgrade-btn" onclick="showUpgradeModal()">⭐ Upgrade</button>
                <button class="auth-btn" onclick="logout()">Logout</button>
            </div>
            
            <!-- Pro user controls -->
            <div class="header-controls" id="proUserControls" style="display: none;">
                <button class="magic-demo-btn" onclick="startMagicDemo('innovation')">
                    ✨ Magic Demo
                </button>
                <a href="/conversations.html" class="auth-btn">📚 My Conversations</a>
                <button class="auth-btn" onclick="logout()">Logout</button>
            </div>
        </div>
    </div>
</div>

        <!-- TOPIC SELECTION -->
        <div class="topics-container">
                <div class="section-header">
                    <h3>💎 Speaker Discovery</h3>
                </div>
                
                <!-- STREAMLINED TOPIC GRID -->
                <div class="topic-types-streamlined">
                    <!-- First Row -->
                    <div class="topic-type-slim" onclick="selectTopic('technology')">
                        <div class="format-icon-small">🤖</div>
                        <div class="topic-title">Technology</div>
                    </div>
                    <div class="topic-type-slim" onclick="selectTopic('money')">
                        <div class="format-icon-small">💰</div>
                        <div class="topic-title">Finance</div>
                    </div>
                    <div class="topic-type-slim" onclick="selectTopic('politics')">
                        <div class="format-icon-small">🌍</div>
                        <div class="topic-title">Politics</div>
                    </div>
                    <div class="topic-type-slim" onclick="selectTopic('selfhelp')">
                        <div class="format-icon-small">🌱</div>
                        <div class="topic-title">Self-Help</div>
                    </div>
                    
                    <!-- Second Row -->
                    <div class="topic-type-slim" onclick="selectTopic('philosophy')">
                        <div class="format-icon-small">🔍</div>
                        <div class="topic-title">Philosophy</div>
                    </div>
                    
                    <div class="topic-type-slim" onclick="selectTopic('physics')">
                        <div class="format-icon-small">⚛️</div>
                        <div class="topic-title">Physics</div>
                    </div>
                </div>
                
                <!-- CUSTOM TOPIC SECTION -->
<div class="custom-topic-section-main">
    <div class="custom-topic-input-container">
        <input type="text" id="customTopicInput" placeholder="e.g., 'Current state of renewable energy' or 'The philosophy of consciousness'..." />
        <button id="addCustomTopicBtn" onclick="selectCustomTopic()" disabled>
            ✏️ Custom Topic
        </button>
    </div>
    <div class="custom-topic-tips">
    </div>
</div>
                    </div>
                

        <!-- SPEAKER SELECTION -->
        <div class="speaker-selection-main active" id="speakerSelectionMain">
            <div class="speaker-header">
                <h3>✨ Speaker Selection</h3>
            </div>
            
            <!-- AI SUGGESTIONS AREA (Hidden initially) -->
            <div class="ai-suggestions-area" id="aiSuggestionsArea" style="display: none;">
                <div class="ai-speakers-grid" id="aiSpeakersGrid">
                    <!-- AI suggestions will be inserted here -->
                </div>
            </div>
            
            <!-- CUSTOM SPEAKER SECTION -->
            <div class="custom-speaker-section-main">
                <div class="custom-speaker-input-container">
                    <input type="text" id="customSpeakerInput" placeholder="Enter any name... e.g., 'Barack Obama', 'Marie Curie', 'Your favorite expert'..." />
                    <button id="addCustomSpeakerBtn" onclick="addCustomSpeaker()" disabled>
                        ➕ Add Speaker
                    </button>
                </div>
                <div class="custom-speaker-tips">
                </div>
            </div>
            
            <!-- SELECTED SPEAKERS DISPLAY -->
            <div class="selected-speakers" id="selectedSpeakers">
                <h4 id="selectedSpeakersTitle">Selected Speakers (0/2):</h4>
                <div id="selectedList">
                    <p style="color: #6c757d; font-style: italic;">No speakers selected yet</p>
                </div>
            </div>
        </div>

        <!-- FORMAT SELECTION -->
        <div class="format-selection-main active" id="formatSelectionMain">
            <div class="format-header">
                <h3>🎛️ Discussion Format</h3>
            </div>
            
            <div class="format-types-grid">
                <div class="format-type-small selected" onclick="changeFormat('arena', 2)" data-format="arena">
                    <div class="format-icon-small">💬</div>
                    <div class="format-info">
                        <div class="format-title-small">Discussion Arena</div>
                        <div class="format-desc-small">One-on-one intellectual discussion</div>
                    </div>
                </div>
                
                <div class="format-type-small" onclick="changeFormat('panel', 3)" data-format="panel">
                    <div class="format-icon-small">💼</div>
                    <div class="format-info">
                        <div class="format-title-small">Panel Discussion</div>
                        <div class="format-desc-small">3 experts share perspectives</div>
                    </div>
                </div>
                
                <div class="format-type-small premium-format" onclick="changeFormat('symposium', 4)" data-format="symposium">
                    <div class="format-icon-small">🏛️</div>
                    <div class="format-info">
                        <div class="format-title-small">Academic Symposium <span class="premium-badge">PRO</span></div>
                        <div class="format-desc-small">4 scholars present research</div>
                    </div>
                </div>
                
                <div class="format-type-small premium-format" onclick="changeFormat('debate', 4)" data-format="debate">
                    <div class="format-icon-small">⚖️</div>
                    <div class="format-info">
                        <div class="format-title-small">Formal Debate <span class="premium-badge">PRO</span></div>
                        <div class="format-desc-small">4 participants argue positions</div>
                    </div>
                </div>
                
                <div class="format-type-small premium-format" onclick="changeFormat('roundtable', 5)" data-format="roundtable">
                    <div class="format-icon-small">🔄</div>
                    <div class="format-info">
                        <div class="format-title-small">Roundtable <span class="premium-badge">PRO</span></div>
                        <div class="format-desc-small">5 minds collaborate</div>
                    </div>
                </div>
                
                <div class="format-type-small" onclick="changeFormat('chat', 1)" data-format="chat">
                    <div class="format-icon-small">🗣️</div>
                    <div class="format-info">
                        <div class="format-title-small">Personal Chat</div>
                        <div class="format-desc-small">One-on-one conversation</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- QUESTION SECTION -->
<div class="question-section-main active" id="questionSectionMain">
    <div class="section-header">
        <h3>💡 Question</h3>
    </div>
    
       <!-- AI Suggestions Button -->
    <div class="ai-suggestions-toggle">
        <button class="question-mode-button" onclick="generateAIQuestions()" id="aiSuggestionsBtn" disabled>
            ⭐ AI Suggestions
        </button>
    </div>
    
    <!-- AI Suggestion Section -->
    <div class="ai-suggestion-section" id="aiSuggestionSection" style="display: none;">
        <div class="suggested-questions" id="suggestedQuestions">
            <!-- AI suggestions will appear here -->
        </div>
    </div>
    
    <div class="question-input-section-main">
        <div class="question-input-container">
            <textarea id="userQuestionInput" 
                     placeholder="e.g., 'What are the most important leadership qualities?' or 'How can we solve climate change?' or 'What makes a great work of art?'..."
                     rows="3"></textarea>
            <button class="start-button" onclick="startDiscussion()" id="startDiscussionBtn" disabled>
                🚀 Start Discussion
            </button>
        </div>
    </div>
</div>


        <!-- DISCUSSION ARENA -->
        <div class="discussion-arena" id="discussionArena"></div>
        
        <!-- DISCUSSION CONTROLS -->
        <div class="discussion-controls" id="discussionControls"></div>
    </div>
    <!-- Auth Modals - Add this before closing </body> tag -->
<div class="auth-modal" id="authModal">
    <div class="auth-content">
        <button class="auth-close" onclick="closeAuthModal()">&times;</button>
        
        <!-- Login Form -->
        <div id="loginForm">
            <div class="auth-header">
                <h2>Welcome Back</h2>
                <p>Sign in to continue your intellectual journey</p>
            </div>
            
            <div class="auth-error" id="loginError"></div>
            
            <form class="auth-form" onsubmit="handleLogin(event)">
                <input type="email" class="auth-input" placeholder="Email" required id="loginEmail">
                <input type="password" class="auth-input" placeholder="Password" required id="loginPassword">
                <button type="submit" class="auth-submit" id="loginSubmit">Sign In</button>
            </form>
            
            <div class="auth-toggle">
                Don't have an account? <a href="#" onclick="switchToSignup()">Sign up</a>
            </div>
        </div>
        
        <!-- Signup Form -->
        <div id="signupForm" style="display: none;">
            <div class="auth-header">
                <h2>Join Iconoclash</h2>
                <p>Start your journey with history's greatest thinkers</p>
            </div>
            
            <div class="auth-error" id="signupError"></div>
            <div class="auth-success" id="signupSuccess"></div>
            
            <form class="auth-form" onsubmit="handleSignup(event)">
                <input type="email" class="auth-input" placeholder="Email" required id="signupEmail">
                <input type="password" class="auth-input" placeholder="Password (min 6 characters)" required id="signupPassword" minlength="6">
                <button type="submit" class="auth-submit" id="signupSubmit">Create Account</button>
            </form>
            
            <div class="auth-toggle">
                Already have an account? <a href="#" onclick="switchToLogin()">Sign in</a>
            </div>
        </div>
    </div>
</div>


    <script>
   
console.log('=== SCRIPT DEBUG START ===');
console.log('Current time:', new Date().toISOString());
console.log('=== SCRIPT DEBUG END ===');
console.log('🚀 Script starting to load...');
window.TEST_FUNCTION = function () {
   console.log('Test function works!');
};
console.log('✅ Test function created');

console.log('JavaScript file loaded successfully!');
window.selectTopic = selectTopic; // Ensure it's globally accessible
console.log('selectTopic function:', typeof selectTopic);
// ============================================================================
// 1. GLOBAL STATE AND CONFIGURATION
// ============================================================================

// Stripe configuration
const STRIPE_PUBLISHABLE_KEY = 'pk_test_51RhLmZCDMgddFpkCd8CBKwCBzTOsx2Aoj2a86E9cGH8HdZLymEMbZBhthz4SpbMjc386psUahOO6Omy7FJclINca00QrgoPJE0';
const STRIPE_PRICE_ID = 'price_1Rr7PrCDMgddFpkCLz4yXyXV'; // $2/month
let stripe = null; // ✅ Initialize as null, will be set when Stripe loads


// Enhanced discussion state to store responses
let discussionState = {
   format: 'arena',
   participantCount: 2,
   participants: [],
   topic: '',
   figure1Mode: 'preset',
   figure2Mode: 'preset',
   chatMode: 'preset',
   responses: [], // Store all responses
   continuationRound: 0, // Track continuation rounds
   totalExchanges: 0, // Track total exchanges
   discussionId: null // Track current discussion session
};

// Track all previously shown speakers to avoid duplicates
let shownSpeakers = new Set();

// Usage tracking for freemium model
let usageState = {
   dailyDiscussions: 0,
   lastResetDate: new Date().toDateString(),
   isProUser: false
};

let currentUser = null;
let authToken = null;

let selectedAISpeakers = [];
let suggestedSpeakers = [];

// ADD THIS NEW ANALYTICS STATE
let analyticsState = {
   userId: null,
   sessionId: null,
   totalSessions: 0,
   formatUsage: {
      arena: 0,
      chat: 0,
      panel: 0,
      symposium: 0,
      debate: 0,
      roundtable: 0
   },
   dailyStats: {},
   firstVisit: null,
   lastVisit: null,

   // ADD USER PROGRESS TRACKING
   userProgress: {
      hasSeenDemo: false,
      hasTriedTwoPerson: false,
      hasExploredFormats: false,
      totalDiscussions: 0,
      preferredExperience: 'guided' // 'guided' or 'advanced'
   }
};

// Question mode management
let currentQuestionMode = 'manual';
let selectedAIQuestion = null;

// Add these to your existing global variables
let selectedTopic = null;
let currentStep = 'topic'; // 'topic' -> 'format' -> 'speakers' -> 'question'

// Topic categories data
const topicCategories = {
   // CURRENT AFFAIRS TOPICS
   politics: {
      name: "Global Leaders",
      icon: "🌍",
      description: "World leaders, diplomats, heads of state, political strategists",
      category: "current",
      speakerGuidance: "Focus on current world leaders, heads of state, diplomats, foreign policy experts, and political figures who are actively shaping global affairs and international relations."
   },
   technology: {
      name: "Technology",
      icon: "💻",
      description: "Tech CEOs, VCs, startup founders, innovation leaders",
      category: "current",
      speakerGuidance: "Focus on current technology leaders, venture capitalists, startup founders, and innovators actively building companies and shaping tech trends today."
   },
   sports: {
      name: "Sports",
      icon: "⚽",
      description: "Active athletes, coaches, sports analysts, journalists",
      category: "current",
      speakerGuidance: "Focus on current athletes, active coaches, sports journalists, and analysts who are part of today's sports conversations."
   },
   entertainment: {
      name: "Entertainment",
      icon: "🎭",
      description: "Musicians, actors, directors, content creators",
      category: "current",
      speakerGuidance: "Focus on current musicians, actors, directors, content creators, and entertainment industry leaders actively creating and shaping entertainment today."
   },
   money: {
      name: "Money",
      icon: "💰",
      description: "Active investors, market analysts, financial strategists",
      category: "current",
      speakerGuidance: "Focus on current investors, fund managers, market analysts, and financial strategists actively managing money and discussing current market trends."
   },
   selfhelp: {
      name: "Self-Help",
      icon: "🌱",
      description: "Personal growth, productivity, habits, motivation",
      category: "current",
      speakerGuidance: "Focus on current self-help authors, productivity experts, and personal development coaches with active practices and recent publications."
   },

   // ACADEMIC TOPICS
   physics: {
      name: "Physics",
      icon: "⚛️",
      description: "Theoretical physics, quantum mechanics, cosmology",
      category: "academic",
      speakerGuidance: "Focus on physicists throughout history who made groundbreaking contributions to our understanding of the universe, from Newton to modern quantum theorists."
   },
   mathematics: {
      name: "Mathematics",
      icon: "📐",
      description: "Pure math, mathematical theory, proofs, abstractions",
      category: "academic",
      speakerGuidance: "Focus on mathematicians throughout history who developed fundamental mathematical concepts, from ancient geometers to modern theorists."
   },
   computing: {
      name: "Computer Science",
      icon: "🧮",
      description: "Computer science theory, algorithms, AI research",
      category: "academic",
      speakerGuidance: "Focus on computer scientists and researchers who developed fundamental computing concepts, from Turing to modern AI researchers."
   },
   philosophy: {
      name: "Analytic Philosophy",
      icon: "🔍",
      description: "Philosophy of language, mind, science, logic, and metaphysics",
      category: "academic",
      speakerGuidance: "Focus on analytic philosophers who worked on philosophy of language, philosophy of mind, philosophy of science, logic, and metaphysics. Include figures like Russell, Wittgenstein, Quine, Davidson, Kripke, Putnam, Dennett, and Chalmers. Exclude moral philosophers and ethicists."
   },
   psychology: {
      name: "Psychology",
      icon: "🎭",
      description: "Human behavior, cognition, mental processes",
      category: "academic",
      speakerGuidance: "Focus on psychologists and researchers who developed our understanding of the human mind, behavior, and cognitive processes."
   },
   arthistory: {
      name: "Art History",
      icon: "🎨",
      description: "Art movements, artistic theory, cultural analysis",
      category: "academic",
      speakerGuidance: "Focus on art historians, critics, and scholars who have analyzed and interpreted artistic movements and cultural significance throughout history."
   },

   // CUSTOM
   custom: {
      name: "Custom Topic",
      icon: "✏️",
      description: "Write your own topic - current affairs or academic",
      category: "custom",
      speakerGuidance: "Describe your topic clearly. For current affairs, mention 'current' or 'today'. For academic subjects, be specific about the field or theory you want to explore."
   }
};

// Load usage from localStorage
function loadUsageState() {
   const saved = localStorage.getItem('usageState');
   if (saved) {
      const parsed = JSON.parse(saved);
      usageState = Object.assign({}, usageState, parsed);
   }
   
   // Check if we need to reset daily counter
   checkAndResetDailyUsage();
}

function saveUsageState() {
   localStorage.setItem('usageState', JSON.stringify(usageState));
}

function checkAndResetDailyUsage() {
   const today = new Date().toDateString();
   if (usageState.lastResetDate !== today) {
      usageState.dailyDiscussions = 0;
      usageState.lastResetDate = today;
      saveUsageState();
   }
}

function getUsageState() {
   checkAndResetDailyUsage();
   return usageState;
}

function selectTopic(topicKey) {
   // Update visual selection
   document.querySelectorAll('.topic-type-slim').forEach(el => {
      el.classList.remove('selected');
   });
   // Add selection to clicked topic
   if (event && event.target) {
      const topicElement = event.target.closest('.topic-type-slim');
      if (topicElement) {
         topicElement.classList.add('selected');
      }
   }
   // Update state
   selectedTopic = topicKey;

   // Show AI suggestions area (which is initially hidden)
   const aiArea = document.getElementById('aiSuggestionsArea');
   if (aiArea) {
      aiArea.style.display = 'block';

      // Show loading in AI area
      const aiGrid = document.getElementById('aiSpeakersGrid');
      if (aiGrid) {
         aiGrid.innerHTML = '<div style="text-align: center; padding: 20px;"><div class="loading-spinner"></div><p>Getting speaker suggestions...</p></div>';
      }

      // Scroll to the AI suggestions area
      setTimeout(() => {
         aiArea.scrollIntoView({
            behavior: 'smooth',
            block: 'center' // Changed from 'start' to 'center'
         });
      }, 100);
   }

   // Get AI speaker suggestions
   getSuggestedSpeakers(topicKey, discussionState.format).then(suggestedSpeakers => {
      populateAISuggestions(suggestedSpeakers);
   }).catch(error => {
      console.error('Error getting speakers:', error);
      const backupSpeakers = getBackupSpeakers(topicKey);
      populateAISuggestions(backupSpeakers);
   });

   // Track topic selection
   trackEvent('topic_selected', {
      topic: topicKey,
      topicName: topicCategories[topicKey].name
   });
}

// Add this function to populate the AI suggestions
function populateAISuggestions(suggestedSpeakers) {
   window.suggestedSpeakers = suggestedSpeakers;

   // Track all shown speakers
   suggestedSpeakers.forEach(speaker => {
      shownSpeakers.add(speaker.name);
   });

   const aiGrid = document.getElementById('aiSpeakersGrid');
   if (!aiGrid) return;

   // Helper function to parse fullDisplay into name and details
   const parseFullDisplay = (fullDisplay) => {
      const match = fullDisplay.match(/^(.+?)\s*\((.+)\)$/);
      if (match) {
         return {
            name: match[1].trim(),
            details: match[2].trim()
         };
      }
      return {
         name: fullDisplay,
         details: ''
      };
   };

   aiGrid.innerHTML = `
        ${suggestedSpeakers.slice(0, 4).map((speaker, index) => {
            const parsed = parseFullDisplay(speaker.fullDisplay);
            return `
                <div class="ai-speaker-card" onclick="selectAISpeaker(${index})">
                    <div class="speaker-name">${parsed.name}</div>
                    <div class="speaker-details">${parsed.details}</div>
                    <div class="speaker-description">${speaker.description}</div>
                </div>
            `;
        }).join('')}
        
        ${suggestedSpeakers.slice(4, 8).map((speaker, index) => {
            const parsed = parseFullDisplay(speaker.fullDisplay);
            return `
                <div class="ai-speaker-card" onclick="selectAISpeaker(${index + 4})">
                    <div class="speaker-name">${parsed.name}</div>
                    <div class="speaker-details">${parsed.details}</div>
                    <div class="speaker-description">${speaker.description}</div>
                </div>
            `;
        }).join('')}
    `;

   // Add the Other Speakers button
   const otherSpeakersButton = document.createElement('div');
   otherSpeakersButton.style.cssText = 'grid-column: 1 / -1; text-align: center; margin-top: 20px;';
   otherSpeakersButton.innerHTML = `
      <button class="other-speakers-button" onclick="refreshSpeakers()" style="
         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
         color: white;
         border: none;
         padding: 12px 24px;
         font-size: 16px;
         font-weight: 600;
         border-radius: 12px;
         cursor: pointer;
         transition: all 0.3s ease;
         box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
      ">
         👥 More Speakers
      </button>
   `;
   aiGrid.appendChild(otherSpeakersButton);
}


async function startDiscussion() {
   console.log('Start discussion called, daily discussions:', usageState.totalDiscussions);

   // Check usage limits for free users
   checkAndResetDailyUsage();
   const dailyLimit = 10;
   if (!currentUser && usageState.dailyDiscussions >= dailyLimit) {
      trackUpgradeFlow('limit_reached', {
         attemptedFormat: discussionState.format,
         lastDiscussionTopic: discussionState.topic
      });
      showUpgradeModal();
      return;
   }

   // Generate a unique discussion ID for this session
   discussionState.discussionId = 'disc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
   console.log('Starting new discussion with ID:', discussionState.discussionId);

   // Validate we have everything needed
   const hasEnoughSpeakers = selectedAISpeakers.length === discussionState.participantCount;
   const userQuestionInput = document.getElementById('userQuestionInput');
   const hasQuestion = userQuestionInput && userQuestionInput.value.trim().length > 10;

   if (!hasEnoughSpeakers || !hasQuestion) {
      showNotification('Please select the required speakers and enter a question', 'info');
      return;
   }

   // Increment usage counter
   checkAndResetDailyUsage();
   usageState.dailyDiscussions++;
   saveUsageState();
   updateUsageDisplayAdvanced({
    userType: currentUser ? 'authenticated' : 'anonymous',
    isProUser: usageState.isProUser,
    remaining: currentUser ? 'unlimited' : Math.max(0, 10 - usageState.dailyDiscussions)
});

   // Set up discussion participants
   discussionState.participants = selectedAISpeakers.map(speaker => ({
      name: speaker.name,
      prompt: speaker.isCustom || speaker.isUserAdded ?
         `You are ${speaker.name}. Embody their personality, knowledge, and speaking style as accurately as possible based on their known work and public statements.` :
         (figures[speaker.name] && figures[speaker.name].prompt) || `You are ${speaker.name}. Speak with their knowledge and perspective.`
   }));

   // Set the question
   discussionState.question = userQuestionInput.value.trim();
   discussionState.topic = discussionState.question; // Make sure both are set

   // Reset continuation tracking for new discussions
   discussionState.continuationRound = 0;
   discussionState.totalExchanges = 0;

   // Track the discussion start
   trackDiscussionStart(
      discussionState.format,
      discussionState.participants,
      discussionState.topic
   );

   // Auto-scroll to position the Start Discussion button at the top
   setTimeout(() => {
      const startBtn = document.getElementById('startDiscussionBtn');
      if (startBtn) {
         // Get the position of the Start Discussion button
         const buttonTop = startBtn.offsetTop;
         // Scroll so the button is at the top of the viewport
         // This will show the button at the top and the discussion area below
         window.scrollTo({
            top: buttonTop - 10,
            behavior: 'smooth'
         });
      }
   }, 100); // Small delay to ensure DOM is updated

   // Start the appropriate discussion format
   if (discussionState.format === 'chat') {
      await runPersonalChat();
   } else if (discussionState.format === 'arena') {
      await runTwoPersonDiscussion();
   } else {
      await runMultiPersonDiscussion();
   }
}

// Add this new function for custom topics
// Update the selectCustomTopic function
function selectCustomTopic() {
   const customTopic = document.getElementById('customTopicInput').value.trim();
   const button = document.getElementById('addCustomTopicBtn');

   if (customTopic.length < 10) {
      // Show feedback in the button
      const originalText = button.textContent;

      button.textContent = 'Need 10+ characters';
      button.style.background = '#dc3545';
      button.style.borderColor = '#dc3545';
      button.style.color = 'white';

      // Reset after 2 seconds
      setTimeout(() => {
         button.textContent = originalText;
         button.style.background = '';
         button.style.borderColor = '';
         button.style.color = '';
      }, 2000);

      // Focus back on input
      document.getElementById('customTopicInput').focus();
      return;
   }

   // Create a dynamic topic entry with AI speaker guidance
   const customTopicData = {
      name: customTopic.length > 50 ? customTopic.substring(0, 50) + '...' : customTopic,
      fullTopic: customTopic,
      icon: "✏️",
      description: "Custom topic",
      category: "custom",
      speakerGuidance: `The user wants to explore: "${customTopic}". Analyze this topic and provide speakers who would have the most relevant expertise and interesting perspectives on this specific subject.`
   };

   // Add to topicCategories if it exists
   if (typeof topicCategories !== 'undefined') {
      topicCategories['custom_user'] = customTopicData;
   }

   // Set as selected topic
   selectedTopic = 'custom_user';

   // SHOW LOADING STATE - Show AI suggestions area with loading message
   const aiSuggestionsArea = document.getElementById('aiSuggestionsArea');
   const aiSpeakersGrid = document.getElementById('aiSpeakersGrid');

   if (aiSuggestionsArea && aiSpeakersGrid) {
      aiSuggestionsArea.style.display = 'block';
      aiSpeakersGrid.innerHTML = `
            <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #667eea;">
                <div class="loading-spinner" style="margin: 0 auto 15px auto;"></div>
                <p style="font-size: 1.1rem; font-weight: 600;">Generating speaker recommendations for "${customTopicData.name}"...</p>
                <p style="color: #6c757d; margin-top: 10px;">Finding the most relevant experts for this topic</p>
            </div>
        `;
   }

   // Generate AI speaker suggestions for the custom topic
   getSuggestedSpeakers('custom_user', discussionState.format).then(suggestedSpeakers => {
      populateAISuggestions(suggestedSpeakers);
   }).catch(error => {
      console.error('Error getting speakers for custom topic:', error);
      if (aiSpeakersGrid) {
         aiSpeakersGrid.innerHTML = `
                <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #dc3545;">
                    <p>❌ Error generating speakers. Please choose speakers manually.</p>
                </div>
            `;
      }
   });

   // Clear the input and disable button
   document.getElementById('customTopicInput').value = '';
   button.disabled = true;

   // Show success feedback
   showNotification('✅ Custom topic selected! Generating speaker suggestions...', 'success');

   // Track custom topic creation
   trackEvent('custom_topic_created', {
      topic: customTopic,
      topicLength: customTopic.length
   });
}

// Update the initialization function
function initializeCustomTopicInput() {
   const customTopicInput = document.getElementById('customTopicInput');
   const addCustomTopicBtn = document.getElementById('addCustomTopicBtn');

   if (customTopicInput && addCustomTopicBtn) {
      customTopicInput.addEventListener('input', function () {
         if (this.value.trim().length > 0) {
            addCustomTopicBtn.disabled = false;
            addCustomTopicBtn.style.opacity = '1';
            addCustomTopicBtn.style.cursor = 'pointer';
         } else {
            addCustomTopicBtn.disabled = true;
            addCustomTopicBtn.style.opacity = '0.5';
            addCustomTopicBtn.style.cursor = 'not-allowed';
         }
      });

      // Also handle keyup for better responsiveness
      customTopicInput.addEventListener('keyup', function () {
         if (this.value.trim().length > 0) {
            addCustomTopicBtn.disabled = false;
            addCustomTopicBtn.style.opacity = '1';
            addCustomTopicBtn.style.cursor = 'pointer';
         } else {
            addCustomTopicBtn.disabled = true;
            addCustomTopicBtn.style.opacity = '0.5';
            addCustomTopicBtn.style.cursor = 'not-allowed';
         }
      });
   }
}

// Add this function to handle Enter key in textarea
function handleCustomTopicKeydown(event) {
   if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      selectCustomTopic();
   }
}

// Function to refresh speakers with new suggestions
async function refreshSpeakers() {
   const aiGrid = document.getElementById('aiSpeakersGrid');
   if (!aiGrid) return;

   // Show loading state
   aiGrid.innerHTML = '<div style="text-align: center; padding: 20px;"><div class="loading-spinner"></div><p>Getting new speaker suggestions...</p></div>';

   try {
      // Convert Set to Array for the excluded speakers
      const excludedSpeakersArray = Array.from(shownSpeakers);
      
      // Get new suggestions excluding already shown speakers
      const newSuggestedSpeakers = await getSuggestedSpeakers(selectedTopic, discussionState.format, excludedSpeakersArray);
      
      // Populate with new suggestions
      populateAISuggestions(newSuggestedSpeakers);
      
      // Show success notification
      showNotification('✨ New speaker suggestions loaded!', 'success');
   } catch (error) {
      console.error('Error refreshing speakers:', error);
      showNotification('Failed to get new speakers. Please try again.', 'error');
      
      // Restore previous suggestions on error
      if (window.suggestedSpeakers) {
         populateAISuggestions(window.suggestedSpeakers);
      }
   }
}

// AI Speaker Suggestion System
async function getSuggestedSpeakers(topic, format, excludedSpeakers = []) {
   try {
      const topicData = topicCategories[topic];
      const topicName = topicData.name;
      const formatName = discussionFormats[format].name;
      const category = topicData.category;
      const speakerGuidance = topicData.speakerGuidance;

      let prompt;

      // Add exclusion instruction if we have excluded speakers
      const exclusionNote = excludedSpeakers.length > 0 ? 
         `\nIMPORTANT: Do NOT suggest any of these people as they have already been shown: ${excludedSpeakers.join(', ')}\n` : '';

      if (category === 'current') {
         // Current Affairs Topics - 4 current, 4 historical
         prompt = `For a ${formatName} discussion about "${topicName}", suggest 8 people who would have the most depth and expertise for this current affairs topic.
${exclusionNote}
${speakerGuidance}

IMPORTANT STRUCTURE:
- First 4 suggestions: CONTEMPORARY figures who are CURRENTLY ACTIVE and highly relevant to this field (alive, recently published, giving speeches, on social media, actively working in this space TODAY)
- Last 4 suggestions: HISTORICAL figures who had profound impact on this field and whose insights remain relevant to current discussions

Consider:
1. Current activity and engagement in this specific field
2. Volume of recent work, commentary, or leadership
3. Impact on current discourse and decision-making
4. Diverse perspectives and approaches
5. People who would create fascinating dialogue about current issues vs historical wisdom

For each person, provide:
- Name
- Brief identifier (current role, company, or key achievement)
- Why they're perfect for this current topic (1-2 sentences focusing on their current relevance)

Format as:
CURRENT LEADERS:
1. **Name (identifier)** - Why they're perfect for this current topic
2. **Name (identifier)** - Why they're perfect for this current topic
3. **Name (identifier)** - Why they're perfect for this current topic
4. **Name (identifier)** - Why they're perfect for this current topic

HISTORICAL VOICES:
5. **Name (identifier)** - Why their historical insights remain relevant to current discussions
6. **Name (identifier)** - Why their historical insights remain relevant to current discussions
7. **Name (identifier)** - Why their historical insights remain relevant to current discussions
8. **Name (identifier)** - Why their historical insights remain relevant to current discussions

Focus on people actively shaping this field today, not just academics who study it.`;

      } else if (category === 'academic') {
         // Academic Topics - 4 contemporary, 4 historical
         prompt = `For a ${formatName} discussion about "${topicName}", suggest 8 people who would have the most depth and expertise for this academic field.
${exclusionNote}

${speakerGuidance}

IMPORTANT STRUCTURE:
- First 4 suggestions: CONTEMPORARY scholars and researchers currently active in this field
- Last 4 suggestions: HISTORICAL figures who made foundational contributions to this field

Consider:
1. Depth of scholarly contribution to this field
2. Impact on the development of the field
3. Diversity of approaches and schools of thought
4. People who would create rich intellectual dialogue
5. Mix of theoretical depth and practical applications

For each person, provide:
- Name
- Brief identifier (dates, institution, or key contribution)
- Why they're perfect for this academic topic (1-2 sentences)

Format as:
CONTEMPORARY SCHOLARS:
1. **Name (identifier)** - Why they're perfect for this academic topic
2. **Name (identifier)** - Why they're perfect for this academic topic
3. **Name (identifier)** - Why they're perfect for this academic topic
4. **Name (identifier)** - Why they're perfect for this academic topic

FOUNDATIONAL THINKERS:
5. **Name (identifier)** - Why they're perfect for this academic topic
6. **Name (identifier)** - Why they're perfect for this academic topic
7. **Name (identifier)** - Why they're perfect for this academic topic
8. **Name (identifier)** - Why they're perfect for this academic topic

Focus on intellectual depth and scholarly contributions rather than popular fame.`;

      } else {
         // Custom topics - use the full topic description
         const fullTopic = topicData.fullTopic || topicName;

         prompt = `For a ${formatName} discussion about "${fullTopic}", suggest 8 people who would have the most depth and expertise for this specific topic.
${exclusionNote}
${speakerGuidance}

Analyze the topic carefully to determine the best mix of contemporary and historical figures:
- If the topic mentions "current", "today", "2024", or similar temporal indicators, prioritize contemporary figures (6 contemporary, 2 historical)
- If the topic is theoretical or academic in nature, use a balanced mix (4 contemporary, 4 historical)
- If the topic is about practical skills or business, prioritize contemporary figures (6 contemporary, 2 historical)

Consider:
1. Direct relevance to the specific topic described
2. Depth of knowledge and expertise in this exact area
3. Different perspectives and approaches
4. People who would create engaging dialogue about this specific subject
5. Mix of practitioners and theorists as appropriate for this topic

For each person, provide:
- Name
- Brief identifier (role, dates, or key achievement)
- Why they're perfect for this specific topic (1-2 sentences)

Format as:
RELEVANT EXPERTS:
1. **Name (identifier)** - Why they're perfect for this specific topic
2. **Name (identifier)** - Why they're perfect for this specific topic
3. **Name (identifier)** - Why they're perfect for this specific topic
4. **Name (identifier)** - Why they're perfect for this specific topic

ADDITIONAL VOICES:
5. **Name (identifier)** - Why they're perfect for this specific topic
6. **Name (identifier)** - Why they're perfect for this specific topic
7. **Name (identifier)** - Why they're perfect for this specific topic
8. **Name (identifier)** - Why they're perfect for this specific topic

Focus entirely on expertise and relevance to: "${fullTopic}"`;
      }

      const response = await callClaude(prompt, true); // true = this is a suggestion, don't count against limit
      return parseSpeakerSuggestions(response);

   } catch (error) {
      console.error('Error getting speaker suggestions:', error);
      return getBackupSpeakers(topic);
   }
}

function parseSpeakerSuggestions(response) {
   const speakers = [];
   const lines = response.split('\n');

   for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Simple parsing - look for lines that start with numbers
      if (line.indexOf('1.') === 0 || line.indexOf('2.') === 0 || line.indexOf('3.') === 0 || 
          line.indexOf('4.') === 0 || line.indexOf('5.') === 0 || line.indexOf('6.') === 0 ||
          line.indexOf('7.') === 0 || line.indexOf('8.') === 0) {
         
         // Split on common separators
         let parts = line.split(' - ');
         if (parts.length < 2) {
            parts = line.split(': ');
         }
         
         if (parts.length >= 2) {
            // Extract name without regex - just use string methods
            let name = parts[0];
            
            // Remove number prefix (1., 2., etc.)
            if (name.indexOf('1.') === 0) name = name.substring(2);
            if (name.indexOf('2.') === 0) name = name.substring(2);
            if (name.indexOf('3.') === 0) name = name.substring(2);
            if (name.indexOf('4.') === 0) name = name.substring(2);
            if (name.indexOf('5.') === 0) name = name.substring(2);
            if (name.indexOf('6.') === 0) name = name.substring(2);
            if (name.indexOf('7.') === 0) name = name.substring(2);
            if (name.indexOf('8.') === 0) name = name.substring(2);
            
            // Remove asterisks
            name = name.split('**').join('');
            name = name.trim();
            
            // Remove parentheses content for clean name
            const parenStart = name.indexOf('(');
            let cleanName = name;
            if (parenStart !== -1) {
               cleanName = name.substring(0, parenStart).trim();
            }
            
            // Get description
            const description = parts.slice(1).join(' - ').trim();
            
            if (cleanName.length > 2 && description.length > 10) {
               speakers.push({
                  name: cleanName,
                  fullDisplay: name,
                  description: description,
                  isCustom: true
               });
            }
         }
      }
   }

   // If we still don't have enough, add some fallback speakers
   if (speakers.length < 4) {
      const fallbacks = [
         { name: 'Albert Einstein', fullDisplay: 'Albert Einstein', description: 'Theoretical physicist and genius', isCustom: true },
         { name: 'Steve Jobs', fullDisplay: 'Steve Jobs', description: 'Apple co-founder and innovator', isCustom: true },
         { name: 'Marie Curie', fullDisplay: 'Marie Curie', description: 'Pioneering scientist', isCustom: true },
         { name: 'Socrates', fullDisplay: 'Socrates', description: 'Ancient Greek philosopher', isCustom: true }
      ];
      
      for (let i = speakers.length; i < 4; i++) {
         if (i < fallbacks.length) {
            speakers.push(fallbacks[i]);
         }
      }
   }

   console.log('Parsed ' + speakers.length + ' speakers');
   return speakers.slice(0, 8);
}

function getGenericBackupSpeakers() {
   // Return a safe set of generic speakers
   return [
      { name: 'Elon Musk', fullDisplay: 'Elon Musk', description: 'Entrepreneur and innovator', isCustom: true },
      { name: 'Neil deGrasse Tyson', fullDisplay: 'Neil deGrasse Tyson', description: 'Astrophysicist and science communicator', isCustom: true },
      { name: 'Albert Einstein', fullDisplay: 'Albert Einstein', description: 'Theoretical physicist', isCustom: true },
      { name: 'Marie Curie', fullDisplay: 'Marie Curie', description: 'Pioneering scientist', isCustom: true },
      { name: 'Steve Jobs', fullDisplay: 'Steve Jobs', description: 'Technology visionary', isCustom: true },
      { name: 'Maya Angelou', fullDisplay: 'Maya Angelou', description: 'Poet and civil rights activist', isCustom: true },
      { name: 'Carl Sagan', fullDisplay: 'Carl Sagan', description: 'Astronomer and science advocate', isCustom: true },
      { name: 'Jane Goodall', fullDisplay: 'Jane Goodall', description: 'Primatologist and conservationist', isCustom: true }
   ];
}

function getBackupSpeakers(topic) {
   // Check if topicCategories exists and has the topic
   if (!topicCategories || !topicCategories[topic]) {
      console.error('Topic not found:', topic);
      // Return generic speakers as fallback
      return getGenericBackupSpeakers();
   }
   
   // Handle custom topics specially
   if (topic === 'custom_user') {
      const topicData = topicCategories[topic];
      const fullTopic = (topicData && topicData.fullTopic) || (topicData && topicData.name) || 'General discussion';

      // Return generic but diverse speakers for custom topics
      return [{
            name: 'Elon Musk',
            fullDisplay: 'Elon Musk',
            description: `Innovative thinker relevant to: ${fullTopic}`,
            isCustom: true
         },
         {
            name: 'Yuval Noah Harari',
            fullDisplay: 'Yuval Noah Harari',
            description: `Historian and author relevant to: ${fullTopic}`,
            isCustom: true
         },
         {
            name: 'Oprah Winfrey',
            fullDisplay: 'Oprah Winfrey',
            description: `Cultural leader relevant to: ${fullTopic}`,
            isCustom: true
         },
         {
            name: 'Neil deGrasse Tyson',
            fullDisplay: 'Neil deGrasse Tyson',
            description: `Science communicator relevant to: ${fullTopic}`,
            isCustom: true
         },
         {
            name: 'Leonardo da Vinci',
            fullDisplay: 'Leonardo da Vinci',
            description: `Renaissance genius relevant to: ${fullTopic}`,
            isCustom: true
         },
         {
            name: 'Albert Einstein',
            fullDisplay: 'Albert Einstein',
            description: `Theoretical physicist relevant to: ${fullTopic}`,
            isCustom: true
         },
         {
            name: 'Socrates',
            fullDisplay: 'Socrates',
            description: `Philosopher relevant to: ${fullTopic}`,
            isCustom: true
         },
         {
            name: 'Marie Curie',
            fullDisplay: 'Marie Curie',
            description: `Pioneering scientist relevant to: ${fullTopic}`,
            isCustom: true
         }
      ];
   }

   // Fallback speakers organized by the new categories
   const backupMap = {
      // CURRENT AFFAIRS
      politics: {
         contemporary: ['Joe Biden', 'Donald Trump', 'Alexandria Ocasio-Cortez', 'Ron DeSantis', 'Kamala Harris', 'Tucker Carlson'],
         historical: ['Abraham Lincoln', 'Winston Churchill']
      },
      // ... add your other backup speakers here
   };

   const topicData = topicCategories[topic];
   const category = topicData && topicData.category || 'academic';

   const speakers = backupMap[topic] || backupMap.philosophy;
   const contemporary = speakers.contemporary || ['Elon Musk', 'Neil deGrasse Tyson', 'Brené Brown', 'Daniel Kahneman'];
   const historical = speakers.historical || ['Albert Einstein', 'Socrates', 'Leonardo da Vinci', 'Marie Curie'];

   // For current affairs, use more contemporary speakers
  const allSpeakers = category === 'current' 
    ? contemporary.concat(historical.slice(0, 2))
    : contemporary.concat(historical);

   return allSpeakers.slice(0, 8).map(name => ({
      name: name,
      fullDisplay: name,
      description: `Expert in ${topicData.name}`,
      isCustom: true
   }));
}

// ✅ DELETE ALL THE DUPLICATE CODE THAT WAS HERE

async function showAISpeakerSuggestions(suggestedSpeakers, format, count) {
   // Store speakers globally so other functions can access them
   window.suggestedSpeakers = suggestedSpeakers;
   selectedAISpeakers = []; // Reset selection

   // Remove loading state
   const loadingElement = document.getElementById('ai-speaker-loading');
   if (loadingElement) {
      loadingElement.remove();
   }

   const topicData = topicCategories[selectedTopic];
   const category = topicData && topicData.category || 'academic';

   // Category-specific headers
   const firstSectionHeader = category === 'current' ?
      '🌟 Current Leaders' :
      '👨‍🎓 Contemporary Scholars';

   const secondSectionHeader = category === 'current' ?
      '📚 Historical Voices' :
      '📜 Foundational Thinkers';

   // Create AI speaker selection UI WITH CUSTOM SPEAKER OPTION
   const speakerSelectionDiv = document.createElement('div');
   speakerSelectionDiv.className = 'speaker-selection active';
   speakerSelectionDiv.id = 'ai-speaker-selection';
   speakerSelectionDiv.innerHTML = `
        <div class="speaker-header">
            <h4>🤖 AI Selected Experts for ${topicData.name}</h4>
            <p>Choose from our recommendations or add your own speakers</p>
        </div>
        
        <div class="ai-speakers-grid">
            <div class="speaker-section-header" style="grid-column: 1 / -1; text-align: center; font-weight: 600; color: #667eea; margin: 10px 0;">
                ${firstSectionHeader}
            </div>
            ${suggestedSpeakers.slice(0, 4).map((speaker, index) => `
                <div class="ai-speaker-card" onclick="selectAISpeaker(${index})">
                    <div class="speaker-name">${speaker.fullDisplay}</div>
                    <div class="speaker-description">${speaker.description}</div>
                </div>
            `).join('')}
            
            <div class="speaker-section-header" style="grid-column: 1 / -1; text-align: center; font-weight: 600; color: #764ba2; margin: 20px 0 10px 0;">
                ${secondSectionHeader}
            </div>
            ${suggestedSpeakers.slice(4, 8).map((speaker, index) => `
                <div class="ai-speaker-card" onclick="selectAISpeaker(${index + 4})">
                    <div class="speaker-name">${speaker.fullDisplay}</div>
                    <div class="speaker-description">${speaker.description}</div>
                </div>
            `).join('')}
            
            <!-- CUSTOM SPEAKER SECTION -->
            <div class="speaker-section-header" style="grid-column: 1 / -1; text-align: center; font-weight: 600; color: #28a745; margin: 20px 0 10px 0;">
                ✏️ Add Your Own Speaker
            </div>
            <div class="custom-speaker-section" style="grid-column: 1 / -1;">
                <div class="custom-speaker-input-container">
                    <input type="text" id="customSpeakerInputAI" placeholder="Enter any name... e.g., 'Barack Obama', 'Marie Curie', 'Your favorite expert'..." />
                    <button id="addCustomSpeakerBtnAI" onclick="addCustomSpeaker()" disabled>
                        ➕ Add Speaker
                    </button>
                </div>
                <div class="custom-speaker-tips">
                </div>
            </div>
        </div>
        
        <div class="selected-speakers" id="selectedSpeakers">
            <h5 id="selectedSpeakersTitle">Selected Speakers (0/${discussionState.participantCount}):</h5>
            <div id="selectedList">
                <p style="color: #6c757d; font-style: italic;">No speakers selected yet</p>
            </div>
        </div>
        
        <!-- FORMAT SELECTION INTEGRATED HERE -->
        <div class="format-selection-integrated">
            <div class="format-header">
                <h4>🎛️ Discussion Format</h4>
                
            </div>
            
            <div class="format-types-grid">
                <div class="format-type-small selected" onclick="changeFormat('arena', 2)" data-format="arena">
                    <div class="format-icon-small">💬</div>
                    <div class="format-info">
                        <div class="format-title-small">Discussion Arena</div>
                        <div class="format-desc-small">One-on-one intellectual discussion</div>
                    </div>
                </div>
                
                <div class="format-type-small" onclick="changeFormat('panel', 3)" data-format="panel">
                    <div class="format-icon-small">🎪</div>
                    <div class="format-info">
                        <div class="format-title-small">Panel Discussion</div>
                        <div class="format-desc-small">3 experts share perspectives</div>
                    </div>
                </div>
                
                <div class="format-type-small premium-format" onclick="changeFormat('symposium', 4)" data-format="symposium">
                    <div class="format-icon-small">🏛️</div>
                    <div class="format-info">
                        <div class="format-title-small">Academic Symposium <span class="premium-badge">PRO</span></div>
                        <div class="format-desc-small">4 scholars present research</div>
                    </div>
                </div>
                
                <div class="format-type-small premium-format" onclick="changeFormat('debate', 4)" data-format="debate">
                    <div class="format-icon-small">⚖️</div>
                    <div class="format-info">
                        <div class="format-title-small">Formal Debate <span class="premium-badge">PRO</span></div>
                        <div class="format-desc-small">4 participants argue positions</div>
                    </div>
                </div>
                
                <div class="format-type-small premium-format" onclick="changeFormat('roundtable', 5)" data-format="roundtable">
                    <div class="format-icon-small">🔄</div>
                    <div class="format-info">
                        <div class="format-title-small">Roundtable <span class="premium-badge">PRO</span></div>
                        <div class="format-desc-small">5 minds collaborate</div>
                    </div>
                </div>
                
                <div class="format-type-small" onclick="changeFormat('chat', 1)" data-format="chat">
                    <div class="format-icon-small">🗣️</div>
                    <div class="format-info">
                        <div class="format-title-small">Personal Chat</div>
                        <div class="format-desc-small">One-on-one conversation</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="speaker-controls">
            <button onclick="proceedWithAISpeakers()" id="proceedButton" disabled>
                Select ${discussionState.participantCount} speaker${discussionState.participantCount !== 1 ? 's' : ''} to continue
            </button>
            <button onclick="showManualSelection()">
                ⚙️ Choose Manually Instead
            </button>
        </div>
    `;

   // Find a safe place to insert
   const container = document.querySelector('.container');
   container.appendChild(speakerSelectionDiv);

   // Initialize custom speaker input
   initializeCustomSpeakerInput();

   // Scroll to the new speaker selection
   speakerSelectionDiv.scrollIntoView({
      behavior: 'smooth',
      block: 'start'
   });
}

function initializeCustomSpeakerInput() {
   // Try both the static HTML version and the JavaScript-generated version
   let input = document.getElementById('customSpeakerInput'); // Static HTML version
   let button = document.getElementById('addCustomSpeakerBtn');

   // If not found, try the AI-generated version
   if (!input) {
      input = document.getElementById('customSpeakerInputAI');
      button = document.getElementById('addCustomSpeakerBtnAI');
   }

   if (!input || !button) return;

   // Enable/disable button based on input
   input.addEventListener('input', function () {
      const value = this.value.trim();
      if (value.length >= 2) {
         button.disabled = false;
         button.textContent = '➕ Add Speaker';
      } else {
         button.disabled = true;
         button.textContent = '➕ Add Speaker';
      }
   });

   // Allow Enter key to add speaker
   input.addEventListener('keydown', function (event) {
      if (event.key === 'Enter' && this.value.trim().length >= 2) {
         event.preventDefault();
         addCustomSpeaker();
      }
   });
}

function addCustomSpeaker() {
   const input = document.getElementById('customSpeakerInput');
   const speakerName = input.value.trim();

   if (speakerName.length < 2) {
      alert('Please enter at least 2 characters for the speaker name');
      return;
   }

   // Check if already selected
   if (selectedAISpeakers.some(s => s.name.toLowerCase() === speakerName.toLowerCase())) {
      alert('This speaker is already selected!');
      return;
   }

   // Check if we're at the limit
   if (selectedAISpeakers.length >= discussionState.participantCount) {
      showNotification(`You can only select ${discussionState.participantCount} speakers for this format`, 'info');
      return;
   }

   // Create custom speaker object
   const customSpeaker = {
      name: speakerName,
      fullDisplay: speakerName,
      description: `Custom speaker: ${speakerName}`,
      isCustom: true,
      isUserAdded: true // Flag to distinguish from AI suggestions
   };

   // Add to selected speakers
   selectedAISpeakers.push(customSpeaker);

   // Clear input
   input.value = '';
   document.getElementById('addCustomSpeakerBtn').disabled = true;

   // Update display
   updateSelectedSpeakerDisplay();
   checkAISuggestionsReadiness();
   updateStartButtonState();

   // Show success feedback
   showNotification(`✅ Added ${speakerName} to your discussion!`, 'success');

   // Track custom speaker addition
   trackEvent('custom_speaker_added', {
      speakerName: speakerName,
      topic: selectedTopic,
      format: discussionState.format,
      totalSelected: selectedAISpeakers.length
   });
}

// Update the selectAISpeaker function to work with mixed selection
function selectAISpeaker(index) {
   // Use window.suggestedSpeakers since that's where we stored them
   const speaker = window.suggestedSpeakers[index];
   const maxSpeakers = discussionState.participantCount;

   if (!speaker) {
      console.error('Speaker not found at index', index);
      return;
   }

   // Check if speaker is already selected
   const speakerIndex = selectedAISpeakers.findIndex(s => s.name === speaker.name);

   if (speakerIndex !== -1) {
      // Remove if already selected
      selectedAISpeakers.splice(speakerIndex, 1);
   } else if (selectedAISpeakers.length < maxSpeakers) {
      // Add if not at limit
      selectedAISpeakers.push(speaker);
   } else {
      // At limit - show message
      showNotification(`You can only select ${maxSpeakers} speakers for this format`, 'info');
      return;
   }

   updateSelectedSpeakerDisplay();
   checkAISuggestionsReadiness();
   updateStartButtonState();
}

// Update the updateSelectedSpeakerDisplay function to handle mixed speakers
function updateSelectedSpeakerDisplay() {
   const selectedList = document.getElementById('selectedList');
   const proceedButton = document.getElementById('proceedButton');
   const selectedCount = document.getElementById('selectedSpeakersTitle');
   const maxSpeakers = discussionState.participantCount;

   // Use window.suggestedSpeakers consistently
   const allSpeakers = window.suggestedSpeakers || [];

   // Update visual selection on AI speaker cards
   document.querySelectorAll('.ai-speaker-card').forEach((card, index) => {
      const speaker = allSpeakers[index];
      if (!speaker) return; // Safety check

      const isSelected = selectedAISpeakers.some(s => s.name === speaker.name);
      if (isSelected) {
         card.classList.add('selected');
      } else {
         card.classList.remove('selected');
      }
   });

   // Update selected count with current format
   if (selectedCount) {
      selectedCount.textContent = `Selected Speakers (${selectedAISpeakers.length}/${maxSpeakers}):`;
   }

   // Update selected list display
   if (selectedList) {
      if (selectedAISpeakers.length > 0) {
         selectedList.innerHTML = selectedAISpeakers.map(s => {
            const iconColor = s.isUserAdded ? '#28a745' : '#667eea';
            const iconSymbol = s.isUserAdded ? '✏️' : '🤖';

            return `<div style="background: white; padding: 8px 12px; margin: 5px 0; border-radius: 6px; border-left: 3px solid ${iconColor}; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 14px;">${iconSymbol}</span>
                    <strong>${s.fullDisplay}</strong>
                    <button onclick="removeSpeaker('${s.name}')" style="margin-left: auto; background: #dc3545; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 12px; cursor: pointer;">×</button>
                </div>`;
         }).join('');
      } else {
         selectedList.innerHTML = '<p style="color: #6c757d; font-style: italic;">No speakers selected yet</p>';
      }
   }

   // Enable/disable proceed button
   if (proceedButton) {
      if (selectedAISpeakers.length === maxSpeakers) {
         proceedButton.disabled = false;
         proceedButton.textContent = `✨ Start ${discussionFormats[discussionState.format].name}`;
      } else {
         proceedButton.disabled = true;
         proceedButton.textContent = `Select ${maxSpeakers - selectedAISpeakers.length} more speaker${maxSpeakers - selectedAISpeakers.length !== 1 ? 's' : ''}`;
      }
   }
}

// Add function to remove speakers
function removeSpeaker(speakerName) {
   const index = selectedAISpeakers.findIndex(s => s.name === speakerName);
   if (index !== -1) {
      selectedAISpeakers.splice(index, 1);
      updateSelectedSpeakerDisplay();
      checkAISuggestionsReadiness();
      updateStartButtonState();

      // Track speaker removal
      trackEvent('speaker_removed', {
         speakerName: speakerName,
         remainingCount: selectedAISpeakers.length
      });
   }
}

function changeFormat(newFormat, newCount) {
   // Check if this is a premium format for non-pro users
   const premiumFormats = ['symposium', 'debate', 'roundtable'];
   const isProUser = currentUser && currentUser.isProUser;
   
   if (!isProUser && premiumFormats.includes(newFormat)) {
      showUpgradeForFeature('format');
      return;
   }

   // Update visual selection
   document.querySelectorAll('.format-type-small').forEach(el => {
      el.classList.remove('selected');
   });
   document.querySelector(`[data-format="${newFormat}"]`).classList.add('selected');

   // Update state
   discussionState.format = newFormat;
   discussionState.participantCount = newCount;

   // Reset selected speakers if we now need fewer
   if (selectedAISpeakers.length > newCount) {
      selectedAISpeakers = selectedAISpeakers.slice(0, newCount);
   }

   // Update the display
   updateSelectedSpeakerDisplay();

   // Update all displays
   updateAllDisplays();

   // Check AI suggestions button readiness after format change
   checkAISuggestionsReadiness();

   // Track format change
   trackEvent('format_changed', {
      newFormat: newFormat,
      newCount: newCount,
      topic: selectedTopic
   });
}


function proceedWithAISpeakers() {

   if (selectedAISpeakers.length !== discussionState.participantCount) {
      showNotification('Please select the required number of speakers', 'info');
      return;
   }

   // Convert AI speakers to discussion participants
   discussionState.participants = selectedAISpeakers.map(speaker => ({
      name: speaker.name,
      prompt: speaker.isCustom ?
         `You are ${speaker.name}. Embody their personality, knowledge, and speaking style as accurately as possible based on their known work and public statements.` :
         (figures[speaker.name] && figures[speaker.name].prompt) || `You are ${speaker.name}. Speak with their knowledge and perspective.`
   }));

   console.log('✅ Participants set:', discussionState.participants.map(p => p.name));

   // Check if question section exists
   const questionSection = document.getElementById('questionSection');
   console.log('❓ Question section:', questionSection ? 'found' : 'NOT FOUND');

   if (questionSection) {
      questionSection.classList.add('active');
      questionSection.style.display = 'block';
      console.log('✅ Question section activated');

      // Scroll to question section
      setTimeout(() => {
         questionSection.scrollIntoView({
            behavior: 'smooth',
            block: 'start'
         });
      }, 100);
   } else {
      console.error('❌ Question section not found! Creating it...');
      // If question section doesn't exist, we need to create it or show it
      createQuestionSection();
   }


   // Check readiness
   setTimeout(() => {
      console.log('🔄 Checking readiness...');
      checkReadiness();
   }, 100);

   // Track selection
   trackEvent('ai_speakers_selected', {
      topic: selectedTopic,
      format: discussionState.format,
      speakers: selectedAISpeakers.map(s => s.name)
   });
}

function createQuestionSection() {
   console.log('🏗️ Creating question section...');

   // Debug: Let's see what elements exist
   console.log('Available elements:');
   console.log('- .container:', document.querySelector('.container'));
   console.log('- .content:', document.querySelector('.content'));

   // Use .container instead of .content
   let contentArea = document.querySelector('.container');
   if (!contentArea) {
      contentArea = document.querySelector('body');
   }
   if (!contentArea) {
      console.error('❌ No container found to create question section');
      return;
   }

   console.log('✅ Using container:', contentArea.tagName, contentArea.className);

   const questionHTML = `
        <div class="question-section active" id="questionSection" style="display: block;">
            <div class="question-header">
                <h4>💭 What should they discuss?</h4>
            </div>
            
            <div class="question-mode-toggle">
                <button type="button" class="question-mode-button active" onclick="toggleQuestionMode('manual')">
                    ✏️ Write Your Own
                </button>
                <button type="button" class="question-mode-button" onclick="toggleQuestionMode('ai')">
                    🤖 AI Suggestions
                </button>
            </div>
            
            <div class="manual-question-section" id="manualQuestionSection">
                <textarea id="userQuestionInput" placeholder="Enter your question or topic here..."></textarea>
            </div>
            
            <div class="ai-suggestion-section" id="aiSuggestionSection" style="display: none;">
                <div class="suggestion-header">
                    <p>Based on your selected participants, here are tailored discussion topics:</p>
                    <button class="generate-suggestions-btn" onclick="generateAIQuestions()" id="generateBtn">
                        ⭐ Generate Questions
                    </button>
                </div>
                
                <div class="suggested-questions" id="suggestedQuestions">
                    <!-- AI suggestions will appear here -->
                </div>
            </div>
            
            <div class="controls">
                <button class="start-button" onclick="startDiscussion()" id="startDiscussionBtn" disabled>
                    🚀 Start Discussion
                </button>
            </div>
        </div>
    `;

   contentArea.insertAdjacentHTML('beforeend', questionHTML);

   // Add event listeners
   const userQuestionInput = document.getElementById('userQuestionInput');
   if (userQuestionInput) {
      userQuestionInput.addEventListener('input', checkReadiness);
   }

   console.log('✅ Question section created');
}

function showManualSelection() {
   // Track that user chose manual selection
   trackEvent('manual_selection_chosen', {
      topic: selectedTopic,
      format: discussionState.format
   });

   // Remove AI selection UI
   const aiSpeakerSelection = document.getElementById('ai-speaker-selection');
aiSpeakerSelection && aiSpeakerSelection.remove();

   // Reset selected speakers
   selectedAISpeakers = [];

   // Show traditional speaker selection
   showSpeakerSelection(discussionState.format);
}


// Figures database
const figures = {
   // Philosophers
   confucius: {
      name: "Confucius",
      prompt: "You are Confucius. Speak with wisdom about social harmony, virtue, and proper relationships. Reference the importance of education, family, and moral cultivation."
   },
   plato: {
      name: "Plato",
      prompt: "You are Plato. Speak about ideals, truth, and the nature of reality. Reference your theory of Forms and beliefs about justice and the ideal state. Use allegories and philosophical reasoning."
   },
   aristotle: {
      name: "Aristotle",
      prompt: "You are Aristotle. Speak as a systematic philosopher and logician. Use logical reasoning and categorical thinking. Reference your teachings on ethics, politics, and human nature."
   },
   descartes: {
      name: "René Descartes",
      prompt: "You are René Descartes. Speak about doubt, certainty, and the separation of mind and body. Reference your method of systematic doubt and 'cogito ergo sum'."
   },
   spinoza: {
      name: "Baruch Spinoza",
      prompt: "You are Baruch Spinoza. Speak about the unity of mind and body, determinism, and ethics. Reference your geometric method and pantheistic philosophy."
   },
   kant: {
      name: "Immanuel Kant",
      prompt: "You are Immanuel Kant. Speak about duty, categorical imperatives, and moral philosophy. Reference the limits of reason and the importance of moral law."
   },
   nietzsche: {
      name: "Friedrich Nietzsche",
      prompt: "You are Friedrich Nietzsche. Speak provocatively about the will to power, the übermensch, and questioning traditional values. Challenge conventional morality."
   },

   // Logic & Computing Pioneers
   boole: {
      name: "George Boole",
      prompt: "You are George Boole. Speak about mathematical logic, Boolean algebra, and the laws of thought. Reference how logic can be expressed mathematically."
   },
   frege: {
      name: "Gottlob Frege",
      prompt: "You are Gottlob Frege. Speak about mathematical logic, the foundations of arithmetic, and formal systems. Reference your work on predicate logic and sense vs. reference."
   },
   russell: {
      name: "Bertrand Russell",
      prompt: "You are Bertrand Russell. Speak about mathematical logic, philosophy of mathematics, and analytic philosophy. Reference Russell's Paradox and logical atomism."
   },
   vonneumann: {
      name: "John von Neumann",
      prompt: "You are John von Neumann. Speak about computer architecture, game theory, and mathematical foundations. Reference the von Neumann architecture and mathematical rigor."
   },
   godel: {
      name: "Kurt Gödel",
      prompt: "You are Kurt Gödel. Speak about mathematical logic, incompleteness theorems, and the limits of formal systems. Reference undecidable propositions in mathematics."
   },
   turing: {
      name: "Alan Turing",
      prompt: "You are Alan Turing. Speak about computation, artificial intelligence, and mathematical logic. Reference the Turing machine, computability, and the Turing test."
   },
   shannon: {
      name: "Claude Shannon",
      prompt: "You are Claude Shannon. Speak about information theory, digital circuits, and communication systems. Reference entropy, bits, and the mathematical theory of communication."
   },

   // Mathematicians  
   leibniz: {
      name: "Gottfried Wilhelm Leibniz",
      prompt: "You are Gottfried Wilhelm Leibniz. Speak about calculus, philosophy, and the principle of sufficient reason. Reference infinitesimals and the best of all possible worlds."
   },
   euler: {
      name: "Leonhard Euler",
      prompt: "You are Leonhard Euler. Speak about mathematics with incredible breadth - number theory, analysis, geometry, and applied mathematics. Reference your prolific contributions and mathematical insight."
   },
   gauss: {
      name: "Carl Friedrich Gauss",
      prompt: "You are Carl Friedrich Gauss. Speak about number theory, analysis, and mathematical precision. Reference your work as the 'Prince of Mathematics' and emphasis on rigor."
   },
   riemann: {
      name: "Bernhard Riemann",
      prompt: "You are Bernhard Riemann. Speak about complex analysis, differential geometry, and the Riemann hypothesis. Reference non-Euclidean geometry and mathematical abstraction."
   },
   cantor: {
      name: "Georg Cantor",
      prompt: "You are Georg Cantor. Speak about set theory, infinity, and different sizes of infinity. Reference your revolutionary work on transfinite numbers and mathematical foundations."
   },
   hilbert: {
      name: "David Hilbert",
      prompt: "You are David Hilbert. Speak about mathematical formalism, axiomatization, and Hilbert's program. Reference mathematical rigor and the quest for complete, consistent foundations."
   },
   tao: {
      name: "Terence Tao",
      prompt: "You are Terence Tao. Speak about modern mathematics, harmonic analysis, and problem-solving. Reference your work on prime numbers and mathematical collaboration."
   },

   // Physicists
   maxwell: {
      name: "James Clerk Maxwell",
      prompt: "You are James Clerk Maxwell. Speak about electromagnetic theory, statistical mechanics, and the unity of physical laws. Reference Maxwell's equations and the electromagnetic field."
   },
   einstein: {
      name: "Albert Einstein",
      prompt: "You are Albert Einstein. Speak about relativity, the nature of space and time, and the unity of physics. Reference thought experiments and the search for fundamental principles."
   },
   bohr: {
      name: "Niels Bohr",
      prompt: "You are Niels Bohr. Speak about quantum mechanics, complementarity, and the Copenhagen interpretation. Reference the dual nature of matter and measurement in quantum systems."
   },
   heisenberg: {
      name: "Werner Heisenberg",
      prompt: "You are Werner Heisenberg. Speak about quantum mechanics, uncertainty principles, and matrix mechanics. Reference the fundamental limits of measurement and knowledge."
   },
   feynman: {
      name: "Richard Feynman",
      prompt: "You are Richard Feynman. Speak with curiosity about physics, using simple explanations and analogies. Reference quantum electrodynamics and the joy of discovery."
   },
   hawking: {
      name: "Stephen Hawking",
      prompt: "You are Stephen Hawking. Speak about black holes, cosmology, and the nature of time. Reference Hawking radiation and the quest to understand the universe."
   },
   witten: {
      name: "Edward Witten",
      prompt: "You are Edward Witten. Speak about string theory, mathematical physics, and the unification of forces. Reference M-theory and the mathematical beauty of physical laws."
   },

   // Artists
   homer: {
      name: "Homer",
      prompt: "You are Homer, the ancient Greek poet. Speak about epic storytelling, heroism, and the human condition. Reference the Iliad, Odyssey, and the power of narrative."
   },
   davinci: {
      name: "Leonardo da Vinci",
      prompt: "You are Leonardo da Vinci. Show Renaissance curiosity about art, science, engineering, and nature. Connect different fields of knowledge with enthusiasm for observation."
   },
   michelangelo: {
      name: "Michelangelo Buonarroti",
      prompt: "You are Michelangelo. Speak passionately about sculpture, painting, and artistic perfection. Reference the divine beauty of human form and artistic dedication."
   },
   shakespeare: {
      name: "William Shakespeare",
      prompt: "You are William Shakespeare. Speak with eloquence about human nature, drama, and the power of language. Reference character, conflict, and the human condition."
   },
   bach: {
      name: "Johann Sebastian Bach",
      prompt: "You are Johann Sebastian Bach. Speak about musical composition, mathematical beauty in music, and spiritual expression through art. Reference counterpoint and musical architecture."
   },
   beethoven: {
      name: "Ludwig van Beethoven",
      prompt: "You are Ludwig van Beethoven. Speak passionately about music as emotional expression and artistic revolution. Reference the power of music to convey deep human feelings."
   },
   picasso: {
      name: "Pablo Picasso",
      prompt: "You are Pablo Picasso. Speak about artistic innovation, breaking traditional forms, and seeing the world in new ways. Reference cubism and constant artistic evolution."
   },

   // Political Leaders
   caesar: {
      name: "Julius Caesar",
      prompt: "You are Julius Caesar. Speak about leadership, military strategy, and political power. Reference the complexities of governance and the burden of command."
   },
   washington: {
      name: "George Washington",
      prompt: "You are George Washington. Speak about leadership, duty, and the founding of nations. Reference the challenges of establishing democratic institutions and peaceful transfer of power."
   },
   bonaparte: {
      name: "Napoleon Bonaparte",
      prompt: "You are Napoleon Bonaparte. Speak about military genius, political reform, and the pursuit of glory. Reference strategy, meritocracy, and the reshaping of Europe."
   },
   lincoln: {
      name: "Abraham Lincoln",
      prompt: "You are Abraham Lincoln. Speak with wisdom about unity, justice, and moral leadership. Use simple language to explain complex ideas and show concern for human dignity."
   },
   gandhi: {
      name: "Mahatma Gandhi",
      prompt: "You are Mahatma Gandhi. Speak about non-violence, moral authority, and social change. Reference satyagraha, civil disobedience, and the power of peaceful resistance."
   },
   roosevelt: {
      name: "Franklin D. Roosevelt",
      prompt: "You are Franklin D. Roosevelt. Speak about leadership during crisis, optimism, and government's role in society. Reference the New Deal and wartime leadership."
   },
   churchill: {
      name: "Winston Churchill",
      prompt: "You are Winston Churchill. Speak with determination, wit, and rhetorical power. Reference wartime leadership, the defense of democracy, and the power of words."
   },

   // Economists
   adamsmith: {
      name: "Adam Smith",
      prompt: "You are Adam Smith. Speak about free markets, the invisible hand, and moral sentiments. Reference how individual self-interest can benefit society when properly channeled."
   },
   ricardo: {
      name: "David Ricardo",
      prompt: "You are David Ricardo. Speak about comparative advantage, trade theory, and the distribution of wealth. Reference how nations benefit from specialization and trade."
   },
   marx: {
      name: "Karl Marx",
      prompt: "You are Karl Marx. Speak about class struggle, capitalism, and historical materialism. Reference the contradictions of capitalism and the need for worker solidarity."
   },
   marshall: {
      name: "Alfred Marshall",
      prompt: "You are Alfred Marshall. Speak about supply and demand, marginal utility, and microeconomic principles. Reference the mathematical foundations of modern economics."
   },
   keynes: {
      name: "John Maynard Keynes",
      prompt: "You are John Maynard Keynes. Speak about macroeconomics, government intervention, and managing economic cycles. Reference the importance of demand management and practical policy."
   },
   friedman: {
      name: "Milton Friedman",
      prompt: "You are Milton Friedman. Speak about free markets, monetarism, and individual choice. Reference the efficiency of markets and the importance of economic freedom."
   },
   samuelson: {
      name: "Paul Samuelson",
      prompt: "You are Paul Samuelson. Speak about mathematical economics, synthesis of economic thought, and rigorous analysis. Reference the scientific approach to economics."
   },

   // Investors
   valentine: {
      name: "Don Valentine",
      prompt: "You are Don Valentine. Speak about venture capital, pattern recognition, and building great companies. Reference the importance of large markets and exceptional teams."
   },
   buffett: {
      name: "Warren Buffett",
      prompt: "You are Warren Buffett. Speak about value investing, business principles, and long-term thinking. Reference buying great companies at fair prices and understanding businesses deeply."
   },
   dalio: {
      name: "Ray Dalio",
      prompt: "You are Ray Dalio. Speak about principles, systematic investing, and understanding economic cycles. Reference radical transparency and evidence-based decision making."
   },
   doerr: {
      name: "John Doerr",
      prompt: "You are John Doerr. Speak about venture capital, OKRs, and scaling technology companies. Reference the intersection of great teams, large markets, and breakthrough technology."
   },
   druckenmiller: {
      name: "Stanley Druckenmiller",
      prompt: "You are Stanley Druckenmiller. Speak about macro investing, risk management, and reading market cycles. Reference the importance of being wrong quickly and right big."
   },
   thiel: {
      name: "Peter Thiel",
      prompt: "You are Peter Thiel. Speak about contrarian thinking, monopolies, and technological progress. Reference the importance of secrets, zero to one innovation, and long-term vision."
   },
   andreessen: {
      name: "Marc Andreessen",
      prompt: "You are Marc Andreessen. Speak about technology investing, software transformation, and venture capital. Reference how software is eating the world and technological disruption."
   },

   // Technology Leaders
   jobs: {
      name: "Steve Jobs",
      prompt: "You are Steve Jobs. Speak about design, innovation, and user experience. Reference the intersection of technology and liberal arts, simplicity, and thinking differently."
   },
   huang: {
      name: "Jensen Huang",
      prompt: "You are Jensen Huang. Speak about GPU computing, AI acceleration, and parallel processing. Reference the transformation from graphics to general-purpose computing."
   },
   bezos: {
      name: "Jeff Bezos",
      prompt: "You are Jeff Bezos. Speak about customer obsession, long-term thinking, and building scalable systems. Reference the importance of working backwards from customer needs."
   },
   nadella: {
      name: "Satya Nadella",
      prompt: "You are Satya Nadella. Speak about cloud computing, cultural transformation, and empowering others. Reference growth mindset and the democratization of technology."
   },
   brin: {
      name: "Sergey Brin",
      prompt: "You are Sergey Brin. Speak about search, organizing information, and ambitious technological projects. Reference the mission to make information universally accessible."
   },
   zuckerberg: {
      name: "Mark Zuckerberg",
      prompt: "You are Mark Zuckerberg. Speak about connecting people, social networks, and the metaverse. Reference the power of giving people voice and building global communities."
   },
   altman: {
      name: "Sam Altman",
      prompt: "You are Sam Altman. Speak about artificial general intelligence, startup ecosystems, and technological progress. Reference the potential and risks of transformative AI."
   }
};

// Discussion formats configuration
const discussionFormats = {
   arena: {
      name: "Discussion Arena",
      participants: 2,
      description: "Classic one-on-one intellectual discussion",
      isMultiPerson: false
   },
   chat: {
      name: "Personal Chat",
      participants: 1,
      description: "One-on-one conversation with any brilliant mind",
      isMultiPerson: false,
      isPersonalChat: true
   },
   panel: {
      name: "Panel Discussion",
      participants: 3,
      description: "Expert knowledge sharing session",
      isMultiPerson: true,
      roleDescription: "Each participant will share their professional perspective, followed by cross-discussion."
   },
   symposium: {
      name: "Academic Symposium",
      participants: 4,
      description: "Scholarly presentations with peer review",
      isMultiPerson: true,
      roleDescription: "Each scholar will present research, then engage in academic peer review and discussion."
   },
   debate: {
      name: "Formal Debate",
      participants: 4,
      description: "Structured argumentative discussion",
      isMultiPerson: true,
      roleDescription: "Participants 1 & 2 will argue FOR the position. Participants 3 & 4 will argue AGAINST."
   },
   roundtable: {
      name: "Roundtable",
      participants: 5,
      description: "Collaborative exploration and consensus building",
      isMultiPerson: true,
      roleDescription: "All participants will collaborate to explore ideas and build solutions together."
   }
};

// ============================================================================
// 2. UTILITY FUNCTIONS
// ============================================================================

function formatResponse(response) {
   if (!response) return '<p></p>';

   let cleanedResponse = response;

   // Remove asterisk actions like *adjusts pipe*
   while (cleanedResponse.indexOf('*') !== -1) {
      const firstStar = cleanedResponse.indexOf('*');
      const secondStar = cleanedResponse.indexOf('*', firstStar + 1);
      
      if (secondStar !== -1) {
         // Remove the content between asterisks
         cleanedResponse = cleanedResponse.substring(0, firstStar) + 
                          cleanedResponse.substring(secondStar + 1);
      } else {
         // Just remove the single asterisk
         cleanedResponse = cleanedResponse.substring(0, firstStar) + 
                          cleanedResponse.substring(firstStar + 1);
      }
   }

   // Clean up extra spaces
   while (cleanedResponse.indexOf('  ') !== -1) {
      cleanedResponse = cleanedResponse.split('  ').join(' ');
   }
   
   cleanedResponse = cleanedResponse.trim();

   // Split into paragraphs for better readability
   if (cleanedResponse.length < 100) {
      return '<p>' + cleanedResponse + '</p>';
   }

   // Split by sentence endings - look for periods, exclamation marks, question marks
   let sentences = [];
   let currentSentence = '';
   
   for (let i = 0; i < cleanedResponse.length; i++) {
      const char = cleanedResponse[i];
      currentSentence += char;
      
      // Check if this is the end of a sentence
      if ((char === '.' || char === '!' || char === '?') && 
          i < cleanedResponse.length - 1 && 
          cleanedResponse[i + 1] === ' ') {
         sentences.push(currentSentence.trim());
         currentSentence = '';
      }
   }
   
   // Add any remaining content as the last sentence
   if (currentSentence.trim().length > 0) {
      sentences.push(currentSentence.trim());
   }

   let paragraphs = [];
   let currentParagraph = [];

   for (let i = 0; i < sentences.length; i++) {
      currentParagraph.push(sentences[i]);

      // Create paragraph breaks at natural points
      if (currentParagraph.length >= 2 &&
         (sentences[i].indexOf('However') !== -1 ||
          sentences[i].indexOf('But ') !== -1 ||
          sentences[i].indexOf('Now') !== -1 ||
          sentences[i].indexOf('The real') !== -1 ||
          sentences[i].indexOf('After all') !== -1 ||
          currentParagraph.length >= 3)) {

         paragraphs.push(currentParagraph.join(' '));
         currentParagraph = [];
      }
   }

   // Add any remaining sentences
   if (currentParagraph.length > 0) {
      paragraphs.push(currentParagraph.join(' '));
   }

   // Return clean, formatted paragraphs with action buttons
   let formattedContent = '';
   for (let i = 0; i < paragraphs.length; i++) {
      formattedContent += '<p>' + paragraphs[i].trim() + '</p>';
   }

   // Only add action buttons for non-chat formats
   if (discussionState.format !== 'chat') {
      formattedContent += '<div class="speaker-actions">' +
                         '<button class="interject-btn" onclick="startInterjection(this)" title="Ask a follow-up or redirect the conversation">' +
                         '💬 Ask Follow-up' +
                         '</button>' +
                         '</div>';
   }
   
   return formattedContent;
}

function assignSpeakerColor(speakerElement, speakerName) {
   // Don't change moderator or user colors
   if (speakerElement.classList.contains('moderator-speaker') ||
      speakerElement.classList.contains('user-speaker')) {
      return;
   }

   // Get list of unique speaker names from discussion state
   const participantNames = discussionState.participants.map(p => p.name);
   const uniqueSpeakers = participantNames.filter((name, index) => participantNames.indexOf(name) === index);  
   const speakerIndex = uniqueSpeakers.indexOf(speakerName);

   if (speakerIndex >= 0) {
      speakerElement.classList.add(`speaker-${speakerIndex + 1}`);
   }
}

function formatModeratorResponse(response) {
   // Handle structured moderator responses with headers
   let formatted = response.replace(/####\s+([^\n]+)/g, '<h4>$1</h4>');
   formatted = formatted.replace(/###\s+([^\n]+)/g, '<h4>$1</h4>');
   formatted = formatted.replace(/##\s+([^\n]+)/g, '<h4>$1</h4>');

   // Split into paragraphs
   let paragraphs = formatted.split('\n\n').filter(p => p.trim());

   return paragraphs.map(p => {
      p = p.trim();
      if (p.includes('<h4>')) {
         return p;
      } else {
         return `<p>${p}</p>`;
      }
   }).join('');
}

function getFormatIcon(format) {
   const icons = {
      arena: '💬',
      panel: '🎪',
      symposium: '🏛️',
      debate: '⚖️',
      roundtable: '🔄'
   };
   return icons[format] || '🎭';
}

function getParticipantLabel(format) {
   const labels = {
      panel: 'Panelists',
      symposium: 'Scholars',
      debate: 'Debaters',
      roundtable: 'Participants'
   };
   return labels[format] || 'Participants';
}

function showNotification(message, type = 'info') {
   // Remove existing notifications
   document.querySelectorAll('.notification').forEach(n => n.remove());

   const notification = document.createElement('div');
   notification.className = `notification ${type}`;
   notification.textContent = message;

   document.body.appendChild(notification);

   // Show notification
   setTimeout(() => {
      notification.classList.add('show');
   }, 100);

   // Hide notification after 3 seconds
   setTimeout(() => {
      notification.classList.remove('show');
      setTimeout(() => {
         if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
         }
      }, 300);
   }, 3000);
}

// Add this function to check for successful payments
async function checkPaymentSuccess() {
   const urlParams = new URLSearchParams(window.location.search);

   if (urlParams.get('success') === 'true') {
      // Payment was successful!
      const pendingSessionId = localStorage.getItem('pendingCheckoutSession');
      
      if (pendingSessionId && authToken) {
         // Verify payment with server
         try {
            const response = await fetch('/api/verify-payment', {
               method: 'POST',
               headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${authToken}`
               },
               body: JSON.stringify({
                  sessionId: pendingSessionId
               })
            });
            
            if (response.ok) {
               const result = await response.json();
               if (result.success) {
                  usageState.isProUser = true;
                  saveUsageState();
                  localStorage.removeItem('pendingCheckoutSession');
                  
                  // Update user data
                  if (currentUser) {
                     currentUser.isProUser = true;
                  }
               }
            }
         } catch (error) {
            console.error('Error verifying payment:', error);
         }
      }
      
      usageState.isProUser = true;
      saveUsageState();
      updateUsageDisplayAdvanced({
    userType: currentUser ? 'authenticated' : 'anonymous',
    isProUser: usageState.isProUser,
    remaining: currentUser ? Math.max(0, 10 - usageState.dailyDiscussions) : Math.max(0, 10 - usageState.dailyDiscussions)
});
      trackUpgradeFlow('payment_completed', {
         conversionComplete: true,
         finalDiscussionsUsed: usageState.totalDiscussions
      });
      trackUpgrade('stripe');

      // Clean up the URL
      window.history.replaceState({}, document.title, window.location.pathname);

      // Show success message
      showNotification('🎉 Welcome to Iconoclash Pro! You now have unlimited discussions.', 'success');

      console.log('Payment successful - user upgraded to Pro');
   }

   if (urlParams.get('canceled') === 'true') {
      trackUpgradeFlow('payment_canceled', {
         reason: 'user_canceled'
      });
      // Payment was canceled
      showNotification('Payment canceled. You can upgrade anytime!', 'info');

      // Clean up the URL
      window.history.replaceState({}, document.title, window.location.pathname);
   }
}

// Initialize Stripe when it's ready
async function initializeStripe() {
   try {
      console.log('🔄 Loading Stripe library...');
      const StripeLib = await loadStripe();

      stripe = StripeLib(STRIPE_PUBLISHABLE_KEY);
      console.log('✅ Stripe initialized successfully');
      return true;
   } catch (error) {
      console.error('❌ Failed to initialize Stripe:', error);
      return false;
   }
}


function addCustomizationHeader() {
   // Check if header already exists
   if (document.querySelector('.customization-header')) return;

   const header = document.createElement('div');
   header.className = 'customization-header';
   header.innerHTML = `
        <div class="custom-header-content">
            <h2>🎛️ Customize Your Experience</h2>
            <p>Now you have full control - choose your format, speakers, and topic</p>
        </div>
    `;

   // Insert before format selection
   const formatSelection = document.querySelector('.format-selection');
   if (formatSelection) {
      formatSelection.parentNode.insertBefore(header, formatSelection);
   }
}

// ADD THE NEW USAGE FUNCTIONS RIGHT HERE
// Update the usage display function
function updateUsageDisplayAdvanced(usage) {
   const indicator = document.getElementById('usageIndicator');
   const proUserControls = document.getElementById('proUserControls');

   if (!indicator) return;

   if (usage.userType === 'anonymous') {
      // Anonymous user - show daily limit
      const remaining = typeof usage.remaining === 'number' ? usage.remaining : 10;
      indicator.innerHTML = `${remaining} free today`;
      indicator.className = remaining <= 2 ? 'usage-indicator low' : 'usage-indicator';
      indicator.style.display = 'block';
   } else if (usage.userType === 'authenticated') {
      // Authenticated user
      if (usage.isProUser) {
         // Hide usage indicator for pro users (pro badge is shown instead)
         indicator.style.display = 'none';
      } else {
         // Pro users get unlimited
         indicator.style.display = 'none';
      }
   }
}

// Update the upgrade modal for authenticated users
function showUpgradeModal() {
   // Remove any existing modal first
   const existingModal = document.querySelector('.upgrade-modal');
   if (existingModal) {
      existingModal.remove();
   }

   const modal = document.createElement('div');
   modal.className = 'upgrade-modal';
   modal.innerHTML = `
        <div class="upgrade-content">
            <h2>🚀 You've used all your free discussions!</h2>
            <p class="upgrade-feature-text">Upgrade to Pro for unlimited discussions with history's greatest minds.</p>
            <div style="margin: 30px 0;">
                <div style="font-size: 36px; font-weight: bold; color: #1976d2;">$2/month</div>
                <div style="color: #666; margin-top: 5px;">Unlimited discussions • Save conversations • All formats</div>
            </div>
            <button onclick="upgradeToProDemo()" style="background: #1976d2; color: white; padding: 15px 30px; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer; margin-right: 10px;">
                Upgrade to Pro
            </button>
            <button onclick="closeUpgradeModal()" style="background: #f5f5f5; color: #666; padding: 15px 30px; border: none; border-radius: 10px; font-size: 16px; cursor: pointer;">
                Maybe Later
            </button>
            <div style="margin-top: 20px; font-size: 14px; color: #999;">
                Anonymous users: 10 free discussions per day • Pro: Unlimited
            </div>
        </div>
    `;

   document.body.appendChild(modal);
}


function closeUpgradeModal() {
   const modal = document.querySelector('.upgrade-modal');
   if (modal) {
      modal.remove();
      console.log('Upgrade modal closed');
   }
}

// New function to show signup prompt for anonymous users
function showSignupPrompt(title, subtitle) {
   // Remove any existing prompt
   const existingPrompt = document.querySelector('.signup-prompt-modal');
   if (existingPrompt) {
      existingPrompt.remove();
   }

   const modal = document.createElement('div');
   modal.className = 'signup-prompt-modal';
   modal.innerHTML = `
        <div class="signup-prompt-content">
            <h2>${title}</h2>
            <p>${subtitle}</p>
            <div style="margin: 30px 0;">
                <div style="font-size: 20px; font-weight: bold; color: #28a745;">✨ Free Account Benefits</div>
                <ul style="text-align: left; margin: 15px 0; padding-left: 20px;">
                    <li><strong>10 total discussions</strong> (vs 3 total anonymous)</li>
                    <li><strong>Save discussion history</strong></li>
                    <li><strong>Advanced features</strong></li>
                    <li><strong>No payment required</strong></li>
                </ul>
            </div>
            <button onclick="showSignup()" style="background: #28a745; color: white; padding: 15px 30px; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer; margin-right: 10px;">
                Sign Up Free
            </button>
            <button onclick="showLogin()" style="background: #667eea; color: white; padding: 15px 30px; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer; margin-right: 10px;">
                Log In
            </button>
            <button onclick="closeSignupPrompt()" style="background: #f5f5f5; color: #666; padding: 15px 30px; border: none; border-radius: 10px; font-size: 16px; cursor: pointer;">
                Maybe Later
            </button>
            <div style="margin-top: 20px; font-size: 14px; color: #999;">
                Anonymous users get 3 total discussions • Free accounts get 10 total discussions
            </div>
        </div>
    `;

   document.body.appendChild(modal);
}

function closeSignupPrompt() {
   const modal = document.querySelector('.signup-prompt-modal');
   if (modal) {
      modal.remove();
   }
}

async function upgradeToProDemo() {
   trackUpgradeFlow('payment_started', {
      paymentMethod: 'stripe'
   });
   try {
      // Create checkout session
      if (!stripe) {
         console.log('Stripe not initialized, initializing now...');
         await initializeStripe();
      }

      // Double-check that Stripe is now available
      if (!stripe) {
         throw new Error('Stripe failed to initialize');
      }

      console.log('Creating checkout session...');
      const headers = {
         'Content-Type': 'application/json',
      };
      
      // Add auth token if available
      if (authToken) {
         headers['Authorization'] = `Bearer ${authToken}`;
      }
      
      const response = await fetch('/api/create-checkout-session', {
         method: 'POST',
         headers: headers,
         body: JSON.stringify({
            priceId: STRIPE_PRICE_ID // Make sure this is set in your config
         })
      });

      console.log('Checkout response status:', response.status);
      
      if (!response.ok) {
         console.error('Checkout session response not OK:', response.status, response.statusText);
         const errorText = await response.text();
         console.error('Error response:', errorText);
         alert('Error creating payment session. Please try again later.');
         return;
      }

      const session = await response.json();

      if (session.error) {
         alert('Error creating checkout session: ' + session.error);
         return;
      }

      // Store session ID for verification after redirect
      localStorage.setItem('pendingCheckoutSession', session.sessionId);
      
      // Redirect to Stripe Checkout
      const result = await stripe.redirectToCheckout({
         sessionId: session.sessionId
      });

      if (result.error) {
         alert('Payment error: ' + result.error.message);
      }

   } catch (error) {
      trackUpgradeFlow('payment_error', {
         error: error.message
      });

      console.error('Upgrade error:', error);
      alert('Something went wrong. Please try again.');
   }
}

function initializeUsageTracking() {
   loadUsageState();
   if (typeof updateAuthUI === 'function') {
      updateAuthUI();
   }
}

   // Analytics tracking functions
   function initializeAnalytics() {
      // Generate or load user ID
      let stored = localStorage.getItem('brilliantMindsAnalytics');
if (stored) {
    analyticsState = Object.assign({}, analyticsState, JSON.parse(stored));
      } else {
         analyticsState.userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
         analyticsState.firstVisit = new Date().toISOString();
      }

      // Generate session ID
      analyticsState.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
      analyticsState.totalSessions++;
      analyticsState.lastVisit = new Date().toISOString();
      analyticsState.sessionStartTime = Date.now();

      // Initialize today's stats
      const today = new Date().toDateString();
      if (!analyticsState.dailyStats[today]) {
         analyticsState.dailyStats[today] = {
            discussions: 0,
            formats: {},
            upgraded: false
         };
      }

      saveAnalytics();

      // Track session start
      trackEvent('session_start');
   }

   function trackEvent(eventType, data = {}) {
      const event = {
         eventType,
         userId: analyticsState.userId,
         sessionId: analyticsState.sessionId,
         timestamp: new Date().toISOString(),
         data
      };

      console.log('📊 Analytics Event:', event);

      // Send to backend (we'll implement this)
      sendAnalyticsEvent(event);
   }

   function trackDiscussionStart(format, participants, topic) {
      // Update format usage
      analyticsState.formatUsage[format]++;

      // Update daily stats
      const today = new Date().toDateString();
      if (!analyticsState.dailyStats[today]) {
         analyticsState.dailyStats[today] = {
            discussions: 0,
            formats: {},
            upgraded: false
         };
      }

      analyticsState.dailyStats[today].discussions++;
      analyticsState.dailyStats[today].formats[format] =
         (analyticsState.dailyStats[today].formats[format] || 0) + 1;

      saveAnalytics();

      // Track the event
      trackEvent('discussion_start', {
         format,
         participantCount: (participants && participants.length) || 0,
         participantNames: (participants && participants.map(p => (p && p.name)).filter(Boolean)) || [],
         topicLength: (topic && topic.length) || 0,
         isProUser: usageState.isProUser,
         dailyDiscussionNumber: usageState.totalDiscussions
      });
   }

   function trackUpgrade(method = 'stripe') {
      const today = new Date().toDateString();
      if (analyticsState.dailyStats[today]) {
         analyticsState.dailyStats[today].upgraded = true;
      }

      saveAnalytics();

      trackEvent('user_upgraded', {
         method,
         discussionsBeforeUpgrade: usageState.totalDiscussions,
         totalDiscussions: usageState.totalDiscussions,
         daysAsUser: calculateDaysAsUser()
      });
   }

   function trackFormatSelection(format) {
      trackEvent('format_selected', {
         format
      });
   }

   function saveAnalytics() {
      localStorage.setItem('brilliantMindsAnalytics', JSON.stringify(analyticsState));
   }

   function calculateDaysAsUser() {
      if (!analyticsState.firstVisit) return 0;
      const first = new Date(analyticsState.firstVisit);
      const now = new Date();
      return Math.floor((now - first) / (1000 * 60 * 60 * 24));
   }

   async function sendAnalyticsEvent(event) {
      try {
         // Use the current origin (works in Codespaces and locally)
         const apiUrl = `${window.location.origin}/api/analytics`;

         await fetch(apiUrl, {
            method: 'POST',
            headers: {
               'Content-Type': 'application/json'
            },
            body: JSON.stringify(event)
         });
      } catch (error) {
         // Fail silently - don't break the app if analytics fails
         console.log('Analytics send failed (non-critical):', error.message);
      }
   }

      // Advanced conversion funnel tracking
   function trackUpgradeFlow(step, data) {
    // Handle default parameter
    if (data === undefined) {
        data = {};
    }
    
    const conversionData = Object.assign({
        step: step,
        discussionsUsed: usageState.totalDiscussions,
        totalDiscussions: usageState.totalDiscussions,
        timeAsUser: calculateDaysAsUser(),
        currentFormat: discussionState.format,
        sessionTime: Date.now() - analyticsState.sessionStartTime
    }, data);

      console.log(`🔥 Conversion Step: ${step}`, conversionData);

      trackEvent('upgrade_flow', conversionData);
   }

   // Track user engagement levels
   function trackEngagement(action, details) {
    // Handle default parameter
    if (details === undefined) {
        details = {};
    }
    
    trackEvent('user_engagement', Object.assign({
        action: action,
        sessionLength: Date.now() - (analyticsState.sessionStartTime || Date.now()),
        discussionsInSession: usageState.totalDiscussions,
        currentFormat: discussionState.format
    }, details));
}

   // Dynamically load Stripe library
   function loadStripe() {
      return new Promise((resolve, reject) => {
         // Check if Stripe is already loaded
         if (window.Stripe) {
            resolve(window.Stripe);
            return;
         }

         // Create script element
         const script = document.createElement('script');
         script.src = 'https://js.stripe.com/v3/';
         script.async = true;

         script.onload = () => {
            if (window.Stripe) {
               console.log('✅ Stripe library loaded successfully');
               resolve(window.Stripe);
            } else {
               console.error('❌ Stripe library failed to load');
               reject(new Error('Stripe library failed to load'));
            }
         };

         script.onerror = () => {
            console.error('❌ Failed to load Stripe script');
            reject(new Error('Failed to load Stripe script'));
         };

         // Add to head
         document.head.appendChild(script);
      });
   }

   function startMagicDemo(demoType) {
      if (demoType === 'innovation') {
         // Set up the demo discussion
         discussionState.format = 'arena';
         discussionState.participantCount = 2;
         discussionState.topic = "How do breakthrough ideas really happen?";

         // Set up Einstein and Steve Jobs
         discussionState.participants = [{
               name: "Albert Einstein",
               prompt: "You are Albert Einstein, the brilliant theoretical physicist. Speak with your characteristic curiosity, humility, and deep insights about the nature of discovery and creativity. Reference your own breakthrough moments and your philosophy about imagination being more important than knowledge."
            },
            {
               name: "Steve Jobs",
               prompt: "You are Steve Jobs, the visionary co-founder of Apple. Speak with your characteristic passion for innovation, design thinking, and connecting disparate ideas. Reference your experiences creating revolutionary products and your philosophy about thinking different."
            }
         ];

         // Clear any existing selections
         if (window.selectedAISpeakers) {
            selectedAISpeakers = [];
         }
         selectedTopic = null;

         // Hide setup sections and show arena
         document.querySelectorAll('.topics-container, .speaker-selection-main, .format-selection-main, .question-section-main').forEach(el => {
            el.style.display = 'none';
         });

         // Show and setup arena
         const arena = document.getElementById('discussionArena');
         arena.style.display = 'block';
         arena.innerHTML = '';

         // Add demo header
         const demoHeader = document.createElement('div');
         demoHeader.className = 'demo-header-section';
         demoHeader.innerHTML = `
            <div class="demo-indicator">✨ Magic Demo</div>
            <div class="demo-title">Einstein vs. Steve Jobs</div>
            <div class="demo-question">"How do breakthrough ideas really happen?"</div>
        `;
         arena.appendChild(demoHeader);

         // Start the discussion using the existing function
         runTwoPersonDiscussion();

         // Track the demo
         trackEvent('magic_demo_started', {
            demoType: 'innovation',
            participants: ['Einstein', 'Steve Jobs']
         });
      }
   }

   function exploreMoreFormats() {
      // Track user wanting to explore more
      trackEvent('demo_to_explore', {
         action: 'explore_formats'
      });

      // Show the format selection
      document.querySelectorAll('.format-selection, .speaker-selection, .question-section').forEach(el => {
         el.style.display = 'block';
      });

      // Scroll to format selection
      document.querySelector('.format-selection').scrollIntoView({
         behavior: 'smooth',
         block: 'start'
      });
   }

   function startFresh() {
      // Track return to demos
      trackEvent('demo_to_fresh', {
         action: 'new_demo'
      });

      // Reload the page to start fresh
      location.reload();
   }
   function callClaudeWithRetry(prompt, maxRetries) {
    // Handle default parameter
    if (maxRetries === undefined) {
        maxRetries = 3;
    }
    
    function attemptCall(attempt) {
        return callClaude(prompt).then(function(result) {
            return result;
        }).catch(function(error) {
            if (attempt === maxRetries) {
                throw error; // Last attempt failed
            }

            if (error.message.includes('Overloaded') || error.message.includes('529')) {
                // Wait before retrying (exponential backoff)
                const delay = Math.pow(2, attempt) * 1000; // 2s, 4s, 8s
                console.log('API overloaded, retrying in ' + (delay/1000) + 's... (attempt ' + attempt + '/' + maxRetries + ')');
                
                return new Promise(function(resolve) {
                    setTimeout(function() {
                        resolve(attemptCall(attempt + 1));
                    }, delay);
                });
            } else {
                throw error; // Don't retry non-overload errors
            }
        });
    }
    
    return attemptCall(1);
}

function shareThisInsight(buttonElement) {
      // Find the parent speaker element
      const speakerElement = buttonElement.closest('.speaker');
      const speakerName = (speakerElement.querySelector('.speaker-name') && speakerElement.querySelector('.speaker-name').textContent);
      const contentElement = speakerElement.querySelector('.speaker-content');

      // Get clean text content (strip HTML)
      const fullContent = contentElement.textContent || contentElement.innerText;

      // Remove the share button text from content
      const cleanContent = fullContent.replace('📤 Share Quote', '').trim();

      // Create compelling quote (limit to ~200 chars for social media)
      let insight = cleanContent.substring(0, 200).trim();

      // Try to end at a sentence if possible
      const lastSentence = insight.lastIndexOf('.');
      const lastExclamation = insight.lastIndexOf('!');
      const lastQuestion = insight.lastIndexOf('?');
      const lastPunctuation = Math.max(lastSentence, lastExclamation, lastQuestion);

      if (lastPunctuation > 100) {
         insight = insight.substring(0, lastPunctuation + 1);
      } else {
         insight += '...';
      }
      // Create shareable quote
      const shareText = `💡 ${speakerName} on "${discussionState.topic}":

"${insight}"

🧠 Generated by AI at BrilliantMinds.com - Experience conversations with history's greatest minds!`;

      // Share via native sharing or clipboard
      if (navigator.share && navigator.canShare({
            text: shareText
         })) {
         navigator.share({
            title: `Insight from ${speakerName}`,
            text: shareText
         }).then(() => {
            trackEvent('insight_shared', {
               speaker: speakerName,
               method: 'native',
               topic: discussionState.topic,
               format: discussionState.format
            });
         }).catch(console.error);
      } else {
         // Fallback to clipboard
         navigator.clipboard.writeText(shareText).then(() => {
            showNotification('💫 Quote copied to clipboard! Paste anywhere to share.', 'success');
            trackEvent('insight_shared', {
               speaker: speakerName,
               method: 'clipboard',
               topic: discussionState.topic,
               format: discussionState.format
            });
         }).catch(() => {
            // Ultimate fallback - show text in modal
            showShareModal(shareText);
         });
      }
}   

function showShareModal(shareText) {
      const modal = document.createElement('div');
      modal.className = 'share-modal';
      modal.innerHTML = `
        <div class="share-content">
            <h3>📤 Share This Insight</h3>
            <textarea readonly onclick="this.select()" style="width: 100%; height: 120px; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">${shareText}</textarea>
            <div style="margin-top: 15px;">
                <button onclick="this.previousElementSibling.select(); document.execCommand('copy'); showNotification('Copied!', 'success');" style="background: #28a745; color: white; padding: 8px 16px; border: none; border-radius: 5px; margin-right: 10px;">
                    📋 Copy
                </button>
                <button onclick="this.closest('.share-modal').remove()" style="background: #6c757d; color: white; padding: 8px 16px; border: none; border-radius: 5px;">
                    Close
                </button>
            </div>
        </div>
    `;

      document.body.appendChild(modal);

      // Auto-focus the textarea
      modal.querySelector('textarea').focus();
      modal.querySelector('textarea').select();
   }

   // ============================================================================
   // CONVERSATION BRANCHING FUNCTIONS
   // ============================================================================
   let branchingState = {
      activeBranches: 0,
      branchHistory: []
   };

   function startInterjection(buttonElement) {
      // Find the parent speaker element
      const speakerElement = buttonElement.closest('.speaker');
      const speakerName = (speakerElement.querySelector('.speaker-name') && speakerElement.querySelector('.speaker-name').textContent);
      const speakerContent = (speakerElement.querySelector('.speaker-content') && speakerElement.querySelector('.speaker-content').textContent);

      // Get context - the content this user is responding to
      const context = speakerContent.replace('📤 Share Quote💬 Ask Follow-up', '').trim();
      const contextPreview = context.length > 100 ? context.substring(0, 100) + '...' : context;

      // Create interjection input right after this speaker
      const interjectionId = `interjection_${Date.now()}`;
      const interjectionHTML = `
        <div class="interjection-input" id="${interjectionId}">
            <div class="context-indicator">
                💬 Responding to ${speakerName}: "${contextPreview}"
            </div>
            <textarea placeholder="Ask a follow-up question, challenge this point, or take the conversation in a new direction..." 
                     id="${interjectionId}_input"></textarea>
            <div class="interjection-actions">
                <button class="interjection-cancel" onclick="cancelInterjection('${interjectionId}')">
                    Cancel
                </button>
                <button class="interjection-submit" onclick="handleInterjectionSubmit('${interjectionId}', '${speakerName}')">
                    💬 Ask This
                </button>
            </div>
        </div>
    `;

      // Store the context in a data attribute for later use
      speakerElement.setAttribute('data-context', context);

      // Insert the interjection input after the current speaker
      speakerElement.insertAdjacentHTML('afterend', interjectionHTML);

      // Focus on the textarea
      const textarea = document.getElementById(`${interjectionId}_input`);
      textarea.focus();

      // Scroll to the input
      document.getElementById(interjectionId).scrollIntoView({
         behavior: 'smooth',
         block: 'center'
      });

      // Hide the interject button temporarily
      buttonElement.style.display = 'none';

      // Track interjection start
      trackEvent('interjection_started', {
         respondingTo: speakerName,
         format: discussionState.format,
         totalExchanges: discussionState.totalExchanges
      });
   }

   // Add this new helper function
   function handleInterjectionSubmit(interjectionId, speakerName) {
      const interjectionElement = document.getElementById(interjectionId);
      const speakerElement = interjectionElement.previousElementSibling;
      const context = speakerElement.getAttribute('data-context');

      submitInterjection(interjectionId, speakerName, context);
   }

   function cancelInterjection(interjectionId) {
      const interjectionElement = document.getElementById(interjectionId);
      const speakerElement = interjectionElement.previousElementSibling;

      // Show the interject button again
      const interjectionBtn = speakerElement.querySelector('.interject-btn');
      if (interjectionBtn) {
         interjectionBtn.style.display = 'flex';
      }

      // Remove the interjection input
      interjectionElement.remove();
   }

   async function submitInterjection(interjectionId, respondingToSpeaker, originalContext) {
      const textarea = document.getElementById(`${interjectionId}_input`);
      const userQuestion = textarea.value.trim();

      if (userQuestion.length < 5) {
         alert('Please enter a more substantial question or comment');
         return;
      }

      const interjectionElement = document.getElementById(interjectionId);

      // Replace input with user's interjection as a speaker tile
      const userInterjectionHTML = `
        <div class="speaker user-interjection">
            <div class="speaker-name">You</div>
            <div class="speaker-content">
                <p>${userQuestion}</p>
            </div>
        </div>
    `;

      interjectionElement.outerHTML = userInterjectionHTML;

      // Wait a moment for DOM to update, then find the user interjection
      setTimeout(async () => {
         // Find the user interjection we just created
         const allUserInterjections = document.querySelectorAll('.user-interjection');
         const userInterjection = allUserInterjections[allUserInterjections.length - 1];

         if (!userInterjection) {
            console.error('Could not find user interjection element');
            return;
         }

         // Create a branch container for the responses
         const branchContainer = document.createElement('div');
         branchContainer.className = 'branch-container';
         branchContainer.id = `branch_${Date.now()}`;

         // Insert branch container after the user interjection
         userInterjection.insertAdjacentElement('afterend', branchContainer);

         // Get responses from participants
         await getBranchedResponses(branchContainer, userQuestion, respondingToSpeaker, originalContext);

         // Add return to main discussion option
         addBranchReturn(branchContainer);

         // Track successful interjection
         trackEvent('interjection_submitted', {
            respondingTo: respondingToSpeaker,
            questionLength: userQuestion.length,
            format: discussionState.format
         });

         // Update usage counter
         checkAndResetDailyUsage();
         usageState.dailyDiscussions++;
         saveUsageState();
         updateUsageDisplayAdvanced({
    userType: currentUser ? 'authenticated' : 'anonymous',
    isProUser: usageState.isProUser,
    remaining: currentUser ? 'unlimited' : Math.max(0, 10 - usageState.dailyDiscussions)
});

      }, 100); // Small delay to let DOM update
   }

   async function getBranchedResponses(container, userQuestion, originalSpeaker, originalContext) {
      // First, get a response from the speaker they were responding to
      const respondingParticipant = discussionState.participants.find(p =>
         p.name === originalSpeaker || originalSpeaker.includes(p.name)
      );

      if (respondingParticipant) {
         await getBranchedResponse(container, respondingParticipant, userQuestion, originalContext, 'direct');
      }

      // Then get responses from other participants who might have insights
      const otherParticipants = discussionState.participants.filter(p =>
         p !== respondingParticipant && p.name !== originalSpeaker
      );

      // Get 1-2 responses from other participants who would have relevant insights
      const maxOtherResponses = Math.min(2, otherParticipants.length);
      for (let i = 0; i < maxOtherResponses; i++) {
         await getBranchedResponse(container, otherParticipants[i], userQuestion, originalContext, 'supporting');
      }
   }

   async function getBranchedResponse(container, participant, userQuestion, originalContext, responseType) {
      const speakerDiv = document.createElement('div');
      speakerDiv.className = 'speaker';
      speakerDiv.innerHTML = `
        <div class="speaker-name">${participant.name}</div>
        <div><span class="loading"></span>Responding to your question...</div>
    `;
      container.appendChild(speakerDiv);

      try {
         let prompt;

         if (responseType === 'direct') {
            prompt = `${participant.prompt}

Someone just asked you a follow-up question about something you said in the discussion about "${discussionState.topic}".

What you originally said: "${originalContext}"

Their question/comment: "${userQuestion}"

Respond directly to their question while staying true to your character and expertise. Be engaging and helpful, and build on the discussion naturally.

Keep your response concise but substantive (100-150 words).`;
         } else {
            prompt = `${participant.prompt}

You're in a discussion about "${discussionState.topic}" and someone just asked: "${userQuestion}"

This question came up in response to another participant's point about: "${originalContext}"

As ${participant.name}, offer your perspective on their question. You might agree, disagree, or add a different angle - whatever feels most authentic to your viewpoint and expertise.

Keep your response concise but substantive (100-150 words).`;
         }

         const response = await callClaude(prompt);

         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div class="speaker-content">${formatResponse(response)}</div>
        `;
         assignSpeakerColor(speakerDiv, participant.name);

      } catch (error) {
         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div class="speaker-content">❌ Error getting response: ${error.message}</div>
        `;
      }
   }

   function addBranchReturn(branchContainer) {
      addBranchContinue(branchContainer); // Use the new function with both buttons
   }

   function returnToMainDiscussion(buttonElement) {
      // Hide the current branch
      const branchContainer = buttonElement.closest('.branch-container');
      branchContainer.style.display = 'none';

      // Scroll to the main discussion controls
      // const controls = document.getElementById('discussionControls');
      // if (controls) {
      //    controls.scrollIntoView({ 
      //        behavior: 'smooth', 
      //        block: 'center' 
      //    });
      // }

      trackEvent('branch_returned', {
         format: discussionState.format
      });
   }

   function addBranchContinue(branchContainer) {
      const continueHTML = `
        <div class="branch-return">
            <button class="return-btn" onclick="continueBranch(this)">
                🔄 Continue This Branch
            </button>
            <button class="return-btn" onclick="returnToMainDiscussion(this)" style="margin-left: 10px;">
                ↩️ Return to Main Discussion
            </button>
        </div>
    `;
      branchContainer.insertAdjacentHTML('beforeend', continueHTML);
   }

   async function continueBranch(buttonElement) {
      // Check usage limits
      checkAndResetDailyUsage();
      const dailyLimit = 10;
      if (!currentUser && usageState.dailyDiscussions >= dailyLimit) {
         showUpgradeModal();
         return;
      }

      // Increment usage
      checkAndResetDailyUsage();
      usageState.dailyDiscussions++;
      saveUsageState();
      updateUsageDisplayAdvanced({
    userType: currentUser ? 'authenticated' : 'anonymous',
    isProUser: usageState.isProUser,
    remaining: currentUser ? 'unlimited' : Math.max(0, 10 - usageState.dailyDiscussions)
});

      const branchContainer = buttonElement.closest('.branch-container');

      // Get the last few speaker responses in this branch for context
      const branchSpeakers = branchContainer.querySelectorAll('.speaker');
      const recentContext = Array.from(branchSpeakers).slice(-3).map(speaker => {
         const name = (speaker.querySelector('.speaker-name') && speaker.querySelector('.speaker-name').textContent) || '';
         const content = (speaker.querySelector('.speaker-content') && speaker.querySelector('.speaker-content').textContent) || '';
         return name + ': ' + (content && content.substring(0, 200)) + '...';
      }).join('\n\n');

      // Continue the branch discussion
      const validParticipants = discussionState.participants.filter(p => p);
      for (let i = 0; i < Math.min(2, validParticipants.length); i++) {
         await getBranchedContinuation(branchContainer, validParticipants[i], recentContext);
      }

      // Update the continue button text
      buttonElement.textContent = '🔄 Go Even Deeper';

      trackEvent('branch_continued', {
         format: discussionState.format
      });
      // ADD THESE LINES:
      // Move main discussion controls to bottom after branch continues
      setTimeout(() => {
         moveControlsToBottom();
      }, 500);
   }

   async function getBranchedContinuation(container, participant, recentContext) {
      const speakerDiv = document.createElement('div');
      speakerDiv.className = 'speaker';
      speakerDiv.innerHTML = `
        <div class="speaker-name">${participant.name}</div>
        <div><span class="loading"></span>Building on the discussion...</div>
    `;
      container.appendChild(speakerDiv);

      try {
         const prompt = `${participant.prompt}

You're continuing a branch of the discussion about "${discussionState.topic}".

Recent conversation in this branch:
${recentContext}

Continue this branch by building on what's been discussed, going deeper into the ideas raised, or exploring new implications. Stay true to your character and perspective.

Keep your response substantive but focused (120-150 words).`;

         const response = await callClaude(prompt);

         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div class="speaker-content">${formatResponse(response)}</div>
        `;
         assignSpeakerColor(speakerDiv, participant.name);

      } catch (error) {
         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div class="speaker-content">❌ Error: ${error.message}</div>
        `;
      }
   }


   // ============================================================================
   // 3. FORMAT SELECTION FUNCTIONS
   // ============================================================================

   async function selectFormat(format, count) {
      // Make sure we have a topic selected first
      if (!selectedTopic) {
         alert('Please select a topic first!');
         return;
      }

      // Update visual selection
      document.querySelectorAll('#formatSelectionSecondary .format-type').forEach(el => {
         el.classList.remove('selected');
      });
      event.target.closest('.format-type').classList.add('selected');

      // Update state
      discussionState.format = format;
      discussionState.participantCount = count;
      discussionState.topic = selectedTopic;

      // Show loading state
      showAISpeakerLoading();

      // Get AI speaker suggestions
      try {
         const suggestedSpeakers = await getSuggestedSpeakers(selectedTopic, format);
         showAISpeakerSuggestions(suggestedSpeakers, format, count);
      } catch (error) {
         console.error('Error getting speakers:', error);
         // Fallback to original speaker selection if AI fails
         showSpeakerSelection(format);
      }

      trackFormatSelection(format);
   }

   function showAISpeakerLoading() {
      // Hide all existing speaker selections
      document.querySelectorAll('.speaker-selection').forEach(el => {
         el.classList.remove('active');
      });

      // Remove any existing loading elements
      const existingLoading = document.getElementById('ai-speaker-loading');
      if (existingLoading) {
         existingLoading.remove();
      }

      // Create loading HTML
      const loadingHTML = `
        <div class="speaker-selection active" id="ai-speaker-loading">
            <div class="speaker-header">
                <h4>🤖 AI is finding the perfect speakers...</h4>
                <p>Analyzing expertise and selecting the most knowledgeable minds for ${topicCategories[selectedTopic].name}</p>
            </div>
            <div style="text-align: center; padding: 40px;">
                <div class="loading-spinner" style="display: inline-block; width: 40px; height: 40px;"></div>
                <p style="margin-top: 20px; color: #6c757d;">This may take a few seconds...</p>
            </div>
        </div>
    `;

      // Find a safe place to insert
      const formatSection = document.getElementById('formatSelectionSecondary');
      if (formatSection) {
         formatSection.insertAdjacentHTML('afterend', loadingHTML);
      }
   }

   function showSpeakerSelection(format) {
      const formatConfig = discussionFormats[format];

      // Hide all speaker selection sections
      document.querySelectorAll('.speaker-selection').forEach(el => {
         el.classList.remove('active');
      });

      if (formatConfig.isPersonalChat) {
         // Show personal chat layout
         document.getElementById('chat-selection').classList.add('active');
      } else if (formatConfig.isMultiPerson) {
         // Show multi-person layout
         document.getElementById('multi-selection').classList.add('active');
         setupMultiPersonLayout(format);
      } else {
         // Show two-person layout
         document.getElementById('arena-selection').classList.add('active');
      }
   }

   function setupMultiPersonLayout(format) {
      const formatConfig = discussionFormats[format];

      // Update header
      document.getElementById('multiTitle').textContent = `${getFormatIcon(format)} Select Your ${getParticipantLabel(format)}`;
      document.getElementById('multiDescription').textContent = formatConfig.description;

      // Show role assignment if needed
      if (formatConfig.roleDescription) {
         document.getElementById('roleAssignment').style.display = 'block';
         document.getElementById('roleTitle').textContent = `${getFormatIcon(format)} ${formatConfig.name} Structure`;
         document.getElementById('roleDescription').textContent = formatConfig.roleDescription;
      } else {
         document.getElementById('roleAssignment').style.display = 'none';
      }

      // Generate participant slots
      generateParticipantSlots(formatConfig.participants, format);
   }

   // ============================================================================
   // 4. PARTICIPANT SELECTION FUNCTIONS
   // ============================================================================

   function toggleMode(figureNum, mode) {
      discussionState[`figure${figureNum}Mode`] = mode;

      const buttons = document.querySelectorAll(`#arena-selection .figure-selection:nth-child(${figureNum}) .mode-button`);
      buttons.forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');

      const select = document.getElementById(`figure${figureNum}`);
      const input = document.getElementById(`figure${figureNum}Custom`);
      const suggestion = document.getElementById(`suggestion${figureNum}`);

      if (mode === 'preset') {
         select.style.display = 'block';
         input.style.display = 'none';
         suggestion.style.display = 'none';
      } else {
         select.style.display = 'none';
         input.style.display = 'block';
         suggestion.style.display = 'block';
         input.focus();
      }
   }

   function toggleMultiMode(participantNum, mode) {
      // Find the correct participant slot
      const participantSlot = document.querySelector(`#participant${participantNum}`).closest('.figure-selection');

      // Update button states within this specific slot
      const buttons = participantSlot.querySelectorAll('.mode-button');
      buttons.forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');

      // Show/hide the appropriate input elements
      const select = document.getElementById(`participant${participantNum}`);
      const input = document.getElementById(`participant${participantNum}Custom`);

      if (mode === 'preset') {
         select.style.display = 'block';
         input.style.display = 'none';
      } else {
         select.style.display = 'none';
         input.style.display = 'block';
         input.focus();
      }
   }

   function toggleChatMode(mode) {
      discussionState.chatMode = mode;

      const buttons = document.querySelectorAll('#chat-selection .mode-button');
      buttons.forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');

      const select = document.getElementById('chatFigure');
      const input = document.getElementById('chatFigureCustom');

      if (mode === 'preset') {
         select.style.display = 'block';
         input.style.display = 'none';
      } else {
         select.style.display = 'none';
         input.style.display = 'block';
         input.focus();
      }
   }

   function updateMultiParticipant(slot, figureId) {
      if (figureId) {
         discussionState.participants[slot - 1] = figures[figureId];
      } else {
         // Set to null instead of delete to maintain array structure
         discussionState.participants[slot - 1] = null;
      }
      checkReadiness();
   }

   function updateCustomMultiParticipant(slot, customName) {
      if (customName.trim()) {
         discussionState.participants[slot - 1] = {
            name: customName.trim(),
            prompt: `You are ${customName.trim()}. Embody their personality, knowledge, and speaking style as accurately as possible.`
         };
      } else {
         // Remove the participant if name is cleared
         discussionState.participants[slot - 1] = null;
      }
      checkReadiness();
   }

   function generateParticipantSlots(count, format) {
      const grid = document.getElementById('participantsGrid');
      grid.innerHTML = '';

      for (let i = 1; i <= count; i++) {
         const slot = document.createElement('div');
         slot.className = 'figure-selection';

         let roleLabel = `Participant ${i}`;
         if (format === 'debate') {
            roleLabel = i <= 2 ? `Pro Side ${i}` : `Con Side ${i-2}`;
         } else if (format === 'symposium') {
            roleLabel = `Scholar ${i}`;
         } else if (format === 'panel') {
            roleLabel = `Expert ${i}`;
         }

         slot.innerHTML = `
            <div class="selection-header">
                <div class="figure-number">${i}</div>
                <div class="figure-title">${roleLabel}</div>
            </div>
            
            <div class="mode-toggle">
                <button class="mode-button active" onclick="toggleMultiMode(${i}, 'preset')">Preset</button>
                <button class="mode-button" onclick="toggleMultiMode(${i}, 'custom')">Custom</button>
            </div>
            
            <select id="participant${i}" onchange="updateMultiParticipant(${i}, this.value)">
                <option value="">Choose a brilliant mind...</option>
                <optgroup label="🤔 Philosophers">
                    <option value="confucius">Confucius (551-479 BCE)</option>
                    <option value="plato">Plato (428-348 BCE)</option>
                    <option value="aristotle">Aristotle (384-322 BCE)</option>
                    <option value="descartes">René Descartes (1596-1650)</option>
                    <option value="spinoza">Baruch Spinoza (1632-1677)</option>
                    <option value="kant">Immanuel Kant (1724-1804)</option>
                    <option value="nietzsche">Friedrich Nietzsche (1844-1900)</option>
                </optgroup>
                <optgroup label="🖥️ Logic & Computing Pioneers">
                    <option value="boole">George Boole (1815-1864)</option>
                    <option value="frege">Gottlob Frege (1848-1925)</option>
                    <option value="russell">Bertrand Russell (1872-1970)</option>
                    <option value="godel">Kurt Gödel (1906-1978)</option>
                    <option value="vonneumann">John von Neumann (1903-1957)</option>
                    <option value="turing">Alan Turing (1912-1954)</option>
                    <option value="shannon">Claude Shannon (1916-2001)</option>
                </optgroup>
                <optgroup label="📐 Mathematicians">
                    <option value="leibniz">Gottfried Wilhelm Leibniz (1646-1716)</option>
                    <option value="euler">Leonhard Euler (1707-1783)</option>
                    <option value="gauss">Carl Friedrich Gauss (1777-1855)</option>
                    <option value="riemann">Bernhard Riemann (1826-1866)</option>
                    <option value="cantor">Georg Cantor (1845-1918)</option>
                    <option value="hilbert">David Hilbert (1862-1943)</option>
                    <option value="tao">Terence Tao (1975-present)</option>
                </optgroup>
                <optgroup label="⚛️ Physicists">
                    <option value="maxwell">James Clerk Maxwell (1831-1879)</option>
                    <option value="einstein">Albert Einstein (1879-1955)</option>
                    <option value="bohr">Niels Bohr (1885-1962)</option>
                    <option value="heisenberg">Werner Heisenberg (1901-1976)</option>
                    <option value="feynman">Richard Feynman (1918-1988)</option>
                    <option value="hawking">Stephen Hawking (1942-2018)</option>
                    <option value="witten">Edward Witten (1951-present)</option>
                </optgroup>
                <optgroup label="🎨 Artists">
                    <option value="homer">Homer (8th century BCE)</option>
                    <option value="davinci">Leonardo da Vinci (1452-1519)</option>
                    <option value="michelangelo">Michelangelo Buonarroti (1475-1564)</option>
                    <option value="shakespeare">William Shakespeare (1564-1616)</option>
                    <option value="bach">Johann Sebastian Bach (1685-1750)</option>
                    <option value="beethoven">Ludwig van Beethoven (1770-1827)</option>
                    <option value="picasso">Pablo Picasso (1881-1973)</option>
                </optgroup>
                <optgroup label="👑 Political Leaders">
                    <option value="caesar">Julius Caesar (100-44 BCE)</option>
                    <option value="washington">George Washington (1732-1799)</option>
                    <option value="bonaparte">Napoleon Bonaparte (1769-1821)</option>
                    <option value="lincoln">Abraham Lincoln (1809-1865)</option>
                    <option value="gandhi">Mahatma Gandhi (1869-1948)</option>
                    <option value="roosevelt">Franklin D. Roosevelt (1882-1945)</option>
                    <option value="churchill">Winston Churchill (1874-1965)</option>
                </optgroup>
                <optgroup label="💰 Economists">
                    <option value="adamsmith">Adam Smith (1723-1790)</option>
                    <option value="ricardo">David Ricardo (1772-1823)</option>
                    <option value="marx">Karl Marx (1818-1883)</option>
                    <option value="marshall">Alfred Marshall (1842-1924)</option>
                    <option value="keynes">John Maynard Keynes (1883-1946)</option>
                    <option value="samuelson">Paul Samuelson (1915-2009)</option>
                    <option value="friedman">Milton Friedman (1912-2006)</option>
                </optgroup>
                <optgroup label="📈 Investors">
                    <option value="valentine">Don Valentine (1932-2019)</option>
                    <option value="buffett">Warren Buffett (1930-present)</option>
                    <option value="druckenmiller">Stanley Druckenmiller (1953-present)</option>
                    <option value="doerr">John Doerr (1951-present)</option>
                    <option value="dalio">Ray Dalio (1949-present)</option>
                    <option value="thiel">Peter Thiel (1967-present)</option>
                    <option value="andreessen">Marc Andreessen (1971-present)</option>
                </optgroup>
                <optgroup label="💻 Technology Leaders">
                    <option value="jobs">Steve Jobs (1955-2011)</option>
                    <option value="bezos">Jeff Bezos (1964-present)</option>
                    <option value="brin">Sergey Brin (1973-present)</option>
                    <option value="nadella">Satya Nadella (1967-present)</option>
                    <option value="huang">Jensen Huang (1963-present)</option>
                    <option value="zuckerberg">Mark Zuckerberg (1984-present)</option>
                    <option value="altman">Sam Altman (1985-present)</option>
                </optgroup>
            </select>
            
            <input type="text" id="participant${i}Custom" class="custom-input" placeholder="Enter any name..." 
                   style="display: none;">
        `;
         grid.appendChild(slot);

         // Add event listener for the custom input - THIS IS THE KEY FIX
         const customInput = document.getElementById(`participant${i}Custom`);
         customInput.addEventListener('input', function () {
            updateCustomMultiParticipant(i, this.value);
         });

         // Add event listener for the select dropdown - THIS IS ALSO KEY
         const selectElement = document.getElementById(`participant${i}`);
         selectElement.addEventListener('change', function () {
            updateMultiParticipant(i, this.value);
         });
      }

      // CRITICAL: Add a final check after all elements are created
      setTimeout(() => {
         checkReadiness();
      }, 100);
   }

   // ============================================================================
   // 5. QUESTION MANAGEMENT FUNCTIONS
   // ============================================================================

   function toggleQuestionMode(mode) {
      currentQuestionMode = mode;

      // Update button states
      document.querySelectorAll('.question-mode-button').forEach(btn => {
         btn.classList.remove('active');
      });
      document.querySelector(`[onclick="toggleQuestionMode('${mode}')"]`).classList.add('active');

      // Show/hide sections
      const manualSection = document.getElementById('manualQuestionSection');
      const aiSection = document.getElementById('aiSuggestionSection');

      if (mode === 'manual') {
         manualSection.style.display = 'block';
         aiSection.style.display = 'none';
      } else {
         manualSection.style.display = 'none';
         aiSection.style.display = 'block';

         // AUTO-GENERATE QUESTIONS when AI mode is selected
         generateAIQuestions();
      }
   }

   function checkAISuggestionsReadiness() {
      const aiButton = document.getElementById('aiSuggestionsBtn');
      if (!aiButton) return;

      // Get the required number of speakers for current format
      const requiredSpeakers = getRequiredSpeakersForFormat();
      const selectedSpeakersCount = getSelectedSpeakersCount();

      if (selectedSpeakersCount >= requiredSpeakers) {
         aiButton.disabled = false;
         aiButton.style.opacity = '1';
         aiButton.style.cursor = 'pointer';
      } else {
         aiButton.disabled = true;
         aiButton.style.opacity = '0.5';
         aiButton.style.cursor = 'not-allowed';
      }
   }

   function getRequiredSpeakersForFormat() {
      // You'll need to adapt this based on your format selection logic
      const selectedFormat = discussionState.format || 'arena';

      const formatRequirements = {
         'chat': 1,
         'arena': 2,
         'panel': 3,
         'symposium': 4,
         'debate': 4,
         'roundtable': 5
      };

      return formatRequirements[selectedFormat] || 2;
   }

   function getSelectedSpeakersCount() {
      // Count selected speakers from the selectedAISpeakers array
      return selectedAISpeakers.length;
   }

   async function generateAIQuestions() {
      const generateBtn = document.getElementById('aiSuggestionsBtn');
      const questionsContainer = document.getElementById('suggestedQuestions');

      // Check if participants are selected based on current format
      let participantCount = 0;
      let participantNames = [];

      // FIRST: Check if we have AI-selected speakers
      if (selectedAISpeakers && selectedAISpeakers.length > 0) {
         participantCount = selectedAISpeakers.length;
         participantNames = selectedAISpeakers.map(s => s.name);
      }
      // THEN: Check manual selections if no AI speakers
      else if (discussionState.format === 'chat') {
         // Check personal chat participant
         const chatFigureElement = document.getElementById('chatFigure');
         const chatCustomElement = document.getElementById('chatFigureCustom');

         const chatFigure = discussionState.chatMode === 'preset' ?
            (chatFigureElement && chatFigureElement.value ? figures[chatFigureElement.value] : null) :
            (chatCustomElement && chatCustomElement.value.trim() ? {
               name: chatCustomElement.value.trim()
            } : null);

         if (chatFigure) {
            participantCount = 1;
            participantNames = [chatFigure.name];
         }
      } else if (discussionState.format === 'arena') {
         // Check arena participants (two-person setup)
         const figure1Element = document.getElementById('figure1');
         const figure1CustomElement = document.getElementById('figure1Custom');
         const figure2Element = document.getElementById('figure2');
         const figure2CustomElement = document.getElementById('figure2Custom');

         let figure1 = null;
         let figure2 = null;

         // Check figure 1
         if (discussionState.figure1Mode === 'preset') {
            if (figure1Element && figure1Element.value) {
               figure1 = figures[figure1Element.value];
            }
         } else {
            if (figure1CustomElement && figure1CustomElement.value.trim()) {
               figure1 = {
                  name: figure1CustomElement.value.trim()
               };
            }
         }

         // Check figure 2
         if (discussionState.figure2Mode === 'preset') {
            if (figure2Element && figure2Element.value) {
               figure2 = figures[figure2Element.value];
            }
         } else {
            if (figure2CustomElement && figure2CustomElement.value.trim()) {
               figure2 = {
                  name: figure2CustomElement.value.trim()
               };
            }
         }

         if (figure1 && figure2) {
            participantCount = 2;
            participantNames = [figure1.name, figure2.name];
         }
      } else {
         // Check multi-person participants
         participantCount = discussionState.participants.filter(p => p).length;
         participantNames = discussionState.participants.filter(p => p).map(p => p.name);
      }

      // Different minimum requirements for different formats
      const minParticipants = discussionState.format === 'chat' ? 1 : 2;
      if (participantCount < minParticipants) {
         const message = discussionState.format === 'chat' ?
            'Please select a conversation partner first!' :
            'Please select at least 2 participants first!';
         alert(message);
         return;
      }

      // Show loading state
      generateBtn.disabled = true;
      generateBtn.innerHTML = '⭐ Generating...';

      // Show the AI suggestions section
      const aiSection = document.getElementById('aiSuggestionSection');
      if (aiSection) {
         aiSection.style.display = 'block';
      }

      const participantNamesString = participantNames.join(', ');
      questionsContainer.innerHTML = `
        <div style="text-align: center; padding: 30px; color: #6c757d;">
            <span class="loading-spinner"></span>
            Generating personalized questions for ${participantNamesString}...
        </div>
    `;

      try {
         const formatName = discussionFormats[discussionState.format].name;
         let prompt;
         
         // Different prompts based on discussion format
         if (discussionState.format === 'debate') {
            // Formal debate format - generate formal propositions
            prompt = `You are an expert debate moderator. Generate 4 formal debate propositions for a structured debate with ${participantNamesString}.

Each proposition MUST:
1. Be a clear statement that can be argued FOR or AGAINST
2. Be a declarative statement (not a question) that takes a clear position
3. Be relevant to the expertise and backgrounds of these participants
4. Create meaningful disagreement where reasonable people can argue both sides

Examples of good debate propositions:
- "Artificial intelligence should be regulated by international law"
- "Individual liberty takes precedence over collective security"
- "Economic growth is more important than environmental protection"

For each proposition, provide:
- The proposition as a clear statement
- A brief explanation of why this would create interesting debate between these specific participants (1 sentence)

Format your response as:
QUESTION 1: [proposition text]
EXPLANATION 1: [brief explanation]

QUESTION 2: [proposition text]
EXPLANATION 2: [brief explanation]

etc.`;
         } else if (discussionState.format === 'arena') {
            // Arena format - generate discussion topics that can be argued from multiple angles
            prompt = `You are an expert discussion moderator. Generate 4 compelling discussion topics for a Discussion Arena between ${participantNamesString}.

Each topic should:
1. Present a clear question or topic that can be explored from multiple perspectives
2. Be relevant to the expertise and backgrounds of these participants
3. Create meaningful intellectual tension based on their different viewpoints
4. Encourage deep exploration and counter-arguments

Topics can be framed as "Should..." questions, "Is it true that..." statements, or open philosophical questions.

For each topic, provide:
- The topic/question (1-2 sentences)
- A brief explanation of why this would create interesting discussion between these specific participants (1 sentence)

Format your response as:
QUESTION 1: [topic text]
EXPLANATION 1: [brief explanation]

QUESTION 2: [topic text]
EXPLANATION 2: [brief explanation]

etc.`;
         } else if (discussionState.format === 'chat') {
            // Chat format - generate conversational questions
            prompt = `You are helping facilitate a personal conversation. Generate 4 engaging conversation starters for a one-on-one chat between the user and ${participantNamesString}.

Each question should:
1. Be personal and conversational in tone
2. Allow ${participantNamesString} to share insights from their unique perspective
3. Encourage storytelling and personal reflection
4. Be accessible yet intellectually stimulating

For each question, provide:
- A conversational question (1-2 sentences)
- A brief explanation of why this would be interesting to explore with this participant (1 sentence)

Format your response as:
QUESTION 1: [question text]
EXPLANATION 1: [brief explanation]

QUESTION 2: [question text]
EXPLANATION 2: [brief explanation]

etc.`;
         } else {
            // Default format for other types
            prompt = `You are an expert discussion moderator. Generate 4 fascinating discussion questions specifically tailored for a ${formatName} between ${participantNamesString}.

Consider their different backgrounds, areas of expertise, time periods, and philosophical perspectives. The questions should:
1. Highlight their different viewpoints
2. Be intellectually stimulating  
3. Allow participants to showcase their unique knowledge
4. Create opportunity for meaningful disagreement or synthesis

For each question, provide:
- A clear, engaging question (1-2 sentences)
- A brief explanation of why this would be interesting for these participants (1 sentence)

Format your response as:
QUESTION 1: [question text]
EXPLANATION 1: [brief explanation]

QUESTION 2: [question text]
EXPLANATION 2: [brief explanation]

etc.`;
         }

         const response = await callClaude(prompt);
         displayAIQuestions(response);

      } catch (error) {
         questionsContainer.innerHTML = `
            <div style="text-align: center; padding: 20px; color: #dc3545;">
                ❌ Error generating questions: ${error.message}
                <br><br>
                <button onclick="generateAIQuestions()" style="background: #dc3545; color: white; padding: 8px 16px; border: none; border-radius: 5px; cursor: pointer;">
                    Try Again
                </button>
            </div>
        `;
      } finally {
         generateBtn.disabled = false;
         generateBtn.innerHTML = '⭐ Generate New Questions';
      }
   }

   function displayAIQuestions(response) {
      const questionsContainer = document.getElementById('suggestedQuestions');

      // Parse the response
      const questions = parseAIQuestions(response);

      if (questions.length === 0) {
         questionsContainer.innerHTML = `
            <div style="text-align: center; padding: 20px; color: #6c757d;">
                No questions could be generated. Please try again.
            </div>
        `;
         return;
      }

      questionsContainer.innerHTML = questions.map((q, index) => `
        <div class="question-suggestion" data-question-index="${index}">
            <div class="question-text">${q.question}</div>
            <div class="question-explanation">${q.explanation}</div>
        </div>
    `).join('');
    
    // Add click handlers after creating the HTML
    document.querySelectorAll('.question-suggestion').forEach((el, index) => {
        el.addEventListener('click', () => selectAIQuestion(index, questions[index].question));
    });
   }

   function parseAIQuestions(response) {
      const questions = [];
      const lines = response.split('\n');

      for (let i = 0; i < lines.length; i++) {
         const line = lines[i].trim();

         if (line.startsWith('QUESTION')) {
            const questionText = line.replace(/^QUESTION \d+:/, '').trim();

            // Look for the explanation on the next line
            let explanation = '';
            if (i + 1 < lines.length) {
               const nextLine = lines[i + 1].trim();
               if (nextLine.startsWith('EXPLANATION')) {
                  explanation = nextLine.replace(/^EXPLANATION \d+:/, '').trim();
               }
            }

            if (questionText) {
               questions.push({
                  question: questionText,
                  explanation: explanation || 'This question explores their different perspectives.'
               });
            }
         }
      }

      return questions;
   }

   function selectAIQuestion(index, questionText) {
      // Remove previous selections
      document.querySelectorAll('.question-suggestion').forEach(el => {
         el.classList.remove('selected');
      });

      // Select this question
      document.querySelectorAll('.question-suggestion')[index].classList.add('selected');
      selectedAIQuestion = questionText;

      // Put the selected question in the textarea
      const questionInput = document.getElementById('userQuestionInput');
      questionInput.value = questionText;
      
      // Trigger input event to notify all listeners
      questionInput.dispatchEvent(new Event('input', { bubbles: true }));

      // Also call updateStartButtonState directly to be sure
      updateStartButtonState();
   }

   // ============================================================================
   // 6. READINESS CHECK
   // ============================================================================

   function checkReadiness() {
      const button = document.getElementById('startDiscussionBtn');
      if (!button) return; // Safety check

      const userQuestionElement = document.getElementById('userQuestionInput');
      const topic = (userQuestionElement && userQuestionElement.value && userQuestionElement.value.trim()) || ''; 

      let hasEnoughParticipants = false;

      // FIRST: Check if we have AI-selected speakers
      if (selectedAISpeakers && selectedAISpeakers.length >= discussionState.participantCount) {
         hasEnoughParticipants = true;
      }
      // THEN: Check manual selections if no AI speakers
      else if (discussionState.format === 'chat') {
         // Check personal chat setup - just need one figure selected
         const chatFigureElement = document.getElementById('chatFigure');
         const chatCustomElement = document.getElementById('chatFigureCustom');

         let chatFigure = null;

         if (discussionState.chatMode === 'preset') {
            if (chatFigureElement && chatFigureElement.value) {
               chatFigure = figures[chatFigureElement.value];
            }
         } else {
            if (chatCustomElement && chatCustomElement.value.trim()) {
               chatFigure = {
                  name: chatCustomElement.value.trim()
               };
            }
         }

         hasEnoughParticipants = !!chatFigure;

      } else if (discussionState.format === 'arena') {
         // Check two-person setup
         const figure1Element = document.getElementById('figure1');
         const figure1CustomElement = document.getElementById('figure1Custom');
         const figure2Element = document.getElementById('figure2');
         const figure2CustomElement = document.getElementById('figure2Custom');

         let figure1 = null;
         let figure2 = null;

         // Check figure 1
         if (discussionState.figure1Mode === 'preset') {
            if (figure1Element && figure1Element.value) {
               figure1 = figures[figure1Element.value];
            }
         } else {
            if (figure1CustomElement && figure1CustomElement.value.trim()) {
               figure1 = {
                  name: figure1CustomElement.value.trim()
               };
            }
         }

         // Check figure 2
         if (discussionState.figure2Mode === 'preset') {
            if (figure2Element && figure2Element.value) {
               figure2 = figures[figure2Element.value];
            }
         } else {
            if (figure2CustomElement && figure2CustomElement.value.trim()) {
               figure2 = {
                  name: figure2CustomElement.value.trim()
               };
            }
         }

         hasEnoughParticipants = figure1 && figure2;

      } else {
         // Check multi-person setup
         hasEnoughParticipants = discussionState.participants.filter(p => p).length >= 2;
      }

      const hasQuestion = currentQuestionMode === 'manual' ? topic : (selectedAIQuestion || topic);

      if (hasEnoughParticipants && hasQuestion) {
         button.disabled = false;
         button.style.opacity = '1';
         button.style.cursor = 'pointer';
      } else {
         button.disabled = true;
         button.style.opacity = '0.5';
         button.style.cursor = 'not-allowed';
      }
   }

   // ============================================================================
   // 7. DISCUSSION EXECUTION FUNCTIONS
   // ============================================================================


   async function runTwoPersonDiscussion() {
      // Hide setup sections
      document.querySelectorAll('.format-selection, .speaker-selection, .question-section').forEach(el => {
         el.style.display = 'none';
      });

      // Show arena
      document.getElementById('discussionArena').style.display = 'block';

      const arena = document.getElementById('discussionArena');
      arena.innerHTML = '';

      // Create opening round
      const openingRound = document.createElement('div');
      openingRound.className = 'discussion-round';
      openingRound.innerHTML = `<div class="round-header">💭 "${discussionState.topic}"</div>`;
      arena.appendChild(openingRound);

      // Get responses from both participants
      const [figure1, figure2] = discussionState.participants;

      await getParticipantResponse(openingRound, figure1, discussionState.topic, 'opening');
      await getParticipantResponse(openingRound, figure2, discussionState.topic, 'response');
      await getParticipantResponse(openingRound, figure1, discussionState.topic, 'follow-up');

      // Add moderator summary
      await getModeratorSummary(arena);

      // Show discussion controls
      showDiscussionControls();
   }

   async function runMultiPersonDiscussion() {
      // Initialize responses array
      discussionState.responses = [];

      // Hide setup sections
      document.querySelectorAll('.format-selection, .speaker-selection, .question-section').forEach(el => {
         el.style.display = 'none';
      });

      // Show arena
      document.getElementById('discussionArena').style.display = 'block';

      const arena = document.getElementById('discussionArena');
      arena.innerHTML = '';

      const format = discussionFormats[discussionState.format];

      // Create opening round with format-specific structure
      const openingRound = document.createElement('div');
      openingRound.className = 'discussion-round';
      openingRound.innerHTML = `
        <div class="phase-indicator">Phase 1: Opening Statements</div>
        <div class="round-header">${format.name}: "${discussionState.topic}"</div>
    `;
      arena.appendChild(openingRound);

      // Get opening statements from each participant
      const validParticipants = discussionState.participants.filter(p => p);
      for (let i = 0; i < validParticipants.length; i++) {
         await getMultiPersonResponse(openingRound, validParticipants[i], 'opening', i);
      }

      // Create response round
      const responseRound = document.createElement('div');
      responseRound.className = 'discussion-round';

      // Format-specific phase 2 descriptions
      let phase2Title = 'Cross-Discussion';
      let phase2Description = 'Participants respond to each other\'s perspectives';

      if (discussionState.format === 'debate') {
         phase2Title = 'Rebuttals';
         phase2Description = 'Each side responds to the opposing arguments';
      } else if (discussionState.format === 'symposium') {
         phase2Title = 'Peer Review';
         phase2Description = 'Scholarly critique and discussion of presented research';
      }

      responseRound.innerHTML = `
        <div class="phase-indicator">Phase 2: ${phase2Title}</div>
        <div class="round-header">${phase2Description}</div>
    `;
      arena.appendChild(responseRound);

      // Get responses from ALL participants
      for (let i = 0; i < validParticipants.length; i++) {
         await getMultiPersonResponse(responseRound, validParticipants[i], 'response', i);
      }

      // For debate format, add a third phase for closing arguments
      if (discussionState.format === 'debate') {
         const closingRound = document.createElement('div');
         closingRound.className = 'discussion-round';
         closingRound.innerHTML = `
            <div class="phase-indicator">Phase 3: Closing Arguments</div>
            <div class="round-header">Final statements from each side</div>
        `;
         arena.appendChild(closingRound);

         // Get closing arguments from all participants
         for (let i = 0; i < validParticipants.length; i++) {
            await getMultiPersonResponse(closingRound, validParticipants[i], 'closing', i);
         }
      }

      // Add moderator summary
      await getModeratorSummary(arena);

      // Show discussion controls
      showDiscussionControls();
   }

   async function runPersonalChat() {
      // Reset continuation tracking for new discussions
      discussionState.continuationRound = 0;
      discussionState.totalExchanges = 0;

      // Hide setup sections
      document.querySelectorAll('.format-selection, .speaker-selection, .question-section').forEach(el => {
         el.style.display = 'none';
      });

      // Show arena
      document.getElementById('discussionArena').style.display = 'block';

      const arena = document.getElementById('discussionArena');
      arena.innerHTML = '';

      // Create opening round
      const openingRound = document.createElement('div');
      openingRound.className = 'discussion-round';
      openingRound.innerHTML = `<div class="round-header">🗣️ Personal Chat: "${discussionState.topic}"</div>`;
      arena.appendChild(openingRound);

      // Start the conversation
      const chatFigure = discussionState.participants[0];
      await getChatResponse(openingRound, chatFigure, discussionState.topic);

      // For chat format, automatically show input instead of controls
      showChatInputWithControls();
   }

   async function getChatResponse(container, participant, topic) {
      const speakerDiv = document.createElement('div');
      speakerDiv.className = 'speaker';
      speakerDiv.innerHTML = `
        <div class="speaker-name">${participant.name}</div>
        <div><span class="loading"></span>Thinking...</div>
    `;
      container.appendChild(speakerDiv);

      try {
         const prompt = `${participant.prompt}

You are having a personal conversation with someone who asked: "${topic}"

Respond naturally and engagingly, as if you're having a genuine one-on-one conversation. Be personable, insightful, and authentic to your character. Ask a follow-up question to keep the conversation flowing.

Respond in 120-150 words.`;

         const response = await callClaude(prompt);

         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div class="speaker-content">${formatResponse(response)}</div>
        `;
         assignSpeakerColor(speakerDiv, participant.name);

      } catch (error) {
         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div>❌ Error: ${error.message}</div>
        `;
      }
   }

   async function getParticipantResponse(container, participant, topic, stage) {
      const speakerDiv = document.createElement('div');
      speakerDiv.className = 'speaker';
      speakerDiv.innerHTML = `
        <div class="speaker-name">${participant.name}</div>
        <div><span class="loading"></span>Thinking...</div>
    `;
      container.appendChild(speakerDiv);

      try {
         let prompt;
         if (stage === 'opening') {
            prompt = `${participant.prompt}

You are starting a thoughtful discussion. The question is: "${topic}"

Give your perspective on this question in a CONCISE way (2-3 key points maximum). Be thoughtful and authentic to your historical viewpoint, but focus on your most important insights. Keep it under 150 words.`;
         } else if (stage === 'response') {
            prompt = `${participant.prompt}

You are in a discussion about: "${topic}"

The previous speaker just shared their perspective. Now respond with your own thoughts. In 150 words or less, either:
- Build on their point
- Offer a different perspective  
- Challenge an assumption

Be engaging and thoughtful.`;
         } else {
            prompt = `${participant.prompt}

You are continuing a discussion about: "${topic}"

Reflect on what has been discussed so far and provide a thoughtful follow-up response in 150 words or less.`;
         }

         const response = await callClaude(prompt);

         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div class="speaker-content">${formatResponse(response)}</div>
        `;
         assignSpeakerColor(speakerDiv, participant.name);

      } catch (error) {
         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div>❌ Error: ${error.message}</div>
        `;
      }
   }

   async function getMultiPersonResponse(container, participant, stage, index) {
      const speakerDiv = document.createElement('div');
      speakerDiv.className = 'speaker';
      speakerDiv.innerHTML = `
        <div class="speaker-name">${participant.name}</div>
        <div><span class="loading"></span>Preparing contribution...</div>
    `;
      container.appendChild(speakerDiv);

      try {
         let prompt;
         const formatName = discussionFormats[discussionState.format].name;

         if (stage === 'opening') {
            if (discussionState.format === 'debate') {
               const side = index < 2 ? 'FOR' : 'AGAINST';
               const teamMate = index % 2 === 0 ? 'first speaker' : 'second speaker';
               prompt = `${participant.prompt}

You are the ${teamMate} arguing ${side} this position: "${discussionState.topic}"

Your goal is to build the strongest possible case ${side === 'FOR' ? 'supporting' : 'opposing'} this position. Present compelling evidence, logical reasoning, and persuasive arguments that will be difficult for the opposing side to refute.

Set up arguments that your opponents will struggle to counter. Be confident and substantive while remaining intellectually honest.

Present your opening argument in 120-150 words.`;
            } else if (discussionState.format === 'symposium') {
               prompt = `${participant.prompt}

You are presenting at an ACADEMIC SYMPOSIUM on: "${discussionState.topic}"

Present your scholarly research and findings on this topic. Be rigorous, cite evidence, and present original insights. Use academic language appropriate for peer review.

Present your research in 150-180 words.`;
            } else {
               // Panel or Roundtable
               const context = discussionState.format === 'panel' ? 'as an expert sharing knowledge' : 'collaboratively exploring ideas';
               prompt = `${participant.prompt}

You are participating in a ${formatName} ${context} about: "${discussionState.topic}"

${discussionState.format === 'panel' ? 'As a recognized authority, share your professional perspective and expertise.' : 'Share your perspective while being open to building on others\' ideas.'}

Contribute in 120-150 words.`;
            }
         } else if (stage === 'response') {
            if (discussionState.format === 'debate') {
               const side = index < 2 ? 'FOR' : 'AGAINST';
               const opponentSide = side === 'FOR' ? 'AGAINST' : 'FOR';
               prompt = `${participant.prompt}

You are continuing the FORMAL DEBATE arguing ${side} this position: "${discussionState.topic}"

The ${opponentSide} side has just presented their arguments. You must now deliver a strong rebuttal that:

1. DIRECTLY addresses their strongest points (don't just ignore them)
2. Points out flaws, contradictions, or gaps in their reasoning
3. Presents counter-evidence that undermines their position
4. Reinforces why your ${side} position is superior

Be intellectually aggressive but civil. This is your chance to score points by dismantling their arguments while strengthening your own case. Show why their reasoning fails and yours succeeds.

Present your rebuttal in 120-150 words.`;
            } else if (discussionState.format === 'symposium') {
               prompt = `${participant.prompt}

You are providing PEER REVIEW at an academic symposium on: "${discussionState.topic}"

Critique the presentations you've heard with scholarly rigor. Comment on methodology, evidence, logical consistency, and theoretical implications. Be constructive but thorough in your academic assessment.

Provide your peer review in 120-150 words.`;
            } else {
               // Panel or Roundtable response
               prompt = `${participant.prompt}

You are continuing a ${formatName} about: "${discussionState.topic}"

Others have shared valuable insights. Respond thoughtfully by either building on their points, offering different perspectives, or challenging assumptions respectfully.

Respond in 120-150 words.`;
            }
         } else if (stage === 'closing') {
            // Only for debate format
            const side = index < 2 ? 'FOR' : 'AGAINST';
            const opponentSide = side === 'FOR' ? 'AGAINST' : 'FOR';
            prompt = `${participant.prompt}

You are delivering your CLOSING ARGUMENT in this formal debate ${side} the position: "${discussionState.topic}"

This is your final opportunity to win the debate. You must:

1. Summarize why your ${side} position has prevailed in this exchange
2. Highlight where you successfully refuted the ${opponentSide} side's arguments
3. Point out any concessions or weak points they revealed
4. Make a final compelling case that drives home your victory
5. End with confidence that you've proven your position superior

This is about winning the intellectual battle while maintaining dignity. Show why your side's arguments were stronger, more logical, and more convincing throughout this debate.

Deliver your victory closing in 120-150 words.`;
         }

         const response = await callClaude(prompt);

         // Store the response for later use in the summary
         if (!discussionState.responses) {
            discussionState.responses = [];
         }
         discussionState.responses.push({
            participant: participant.name,
            stage: stage,
            content: response
         });

         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div class="speaker-content">${formatResponse(response)}</div>
        `;
         assignSpeakerColor(speakerDiv, participant.name);

      } catch (error) {
         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div>❌ Error: ${error.message}</div>
        `;
      }
   }

   async function getModeratorSummary(arena) {
      const summaryRound = document.createElement('div');
      summaryRound.className = 'discussion-round';
      arena.appendChild(summaryRound);

      const moderatorDiv = document.createElement('div');
      moderatorDiv.className = 'speaker moderator-speaker';
      moderatorDiv.innerHTML = `
        <div class="speaker-name">AI Moderator</div>
        <div><span class="loading"></span>Analyzing the discussion...</div>
    `;
      summaryRound.appendChild(moderatorDiv);

      try {
         const validParticipants = discussionState.participants.filter(p => p);
         const participantNames = validParticipants.map(p => p.name).join(' and ');
         const formatName = discussionFormats[discussionState.format].name;
         
         // Collect actual discussion content
         const discussionContent = collectDiscussionContent(arena);
         const exchangeCount = discussionState.totalExchanges;
         
         // Scale output based on format and discussion length
         let wordCount = '100-150';
         if (discussionState.format === 'symposium' || discussionState.format === 'roundtable') {
            wordCount = '200-250';
         } else if (discussionState.format === 'panel' || discussionState.format === 'debate') {
            wordCount = '150-200';
         }
         
         // Further scale based on exchange count
         if (exchangeCount > 15) {
            wordCount = wordCount.replace(/\d+/g, match => parseInt(match) + 50);
         }

         let prompt;

         if (discussionState.format === 'debate') {
            const proSide = validParticipants.slice(0, 2).map(p => p.name).join(' and ');
            const conSide = validParticipants.slice(2, 4).map(p => p.name).join(' and ');

            prompt = `You are an AI moderator who just observed a formal debate about "${discussionState.topic}".

The debate structure was:
- PRO side (arguing FOR): ${proSide}
- CON side (arguing AGAINST): ${conSide}

Here is the actual discussion that took place:
${discussionContent}

Based ONLY on what was actually discussed above, provide a balanced summary (${wordCount} words) that includes:
- The main arguments from each side as presented in the discussion
- Strongest points made by each side based on their actual statements
- Areas where the debate was most intense according to the exchanges
- Key questions that emerged from their conversation
- Overall assessment of the debate quality

IMPORTANT: Only reference points, arguments, and insights that were actually made in the discussion above. Do not introduce any external knowledge or hypothetical arguments.`;
         } else if (discussionState.format === 'symposium') {
            prompt = `You are an AI moderator who just observed an academic symposium about "${discussionState.topic}" featuring ${participantNames}.

Here is the actual discussion that took place:
${discussionContent}

Based ONLY on what was actually discussed above, provide an academic summary (${wordCount} words) that includes:
- Key research findings presented by the participants
- Most rigorous methodological approaches mentioned
- Areas of scholarly consensus and disagreement shown in the discussion
- Theoretical implications discussed by the speakers
- Future research directions suggested in their conversation

IMPORTANT: Only reference points, arguments, and insights that were actually made in the discussion above. Do not introduce any external knowledge or hypothetical arguments.`;
         } else {
            // Panel, Roundtable, Arena, Chat
            prompt = `You are an AI moderator who just observed a ${formatName} about "${discussionState.topic}" featuring ${participantNames}.

Here is the actual discussion that took place:
${discussionContent}

Based ONLY on what was actually discussed above, provide a thoughtful summary (${wordCount} words) that highlights:
- Key insights that emerged from the conversation
- Different perspectives shared by the participants
- Areas of agreement and disagreement shown in their exchanges
- Most thought-provoking points raised during the discussion
- Questions worth exploring further based on what was discussed

IMPORTANT: Only reference points, arguments, and insights that were actually made in the discussion above. Do not introduce any external knowledge or hypothetical arguments.`;
         }

         const response = await callClaude(prompt);

         moderatorDiv.innerHTML = `
            <div class="speaker-name">AI Moderator</div>
            <div class="speaker-content">${formatModeratorResponse(response)}</div>
        `;

      } catch (error) {
         console.error('Moderator summary error:', error);
         moderatorDiv.innerHTML = `
            <div class="speaker-name">AI Moderator</div>
            <div class="speaker-content">
                <p><strong>Discussion Summary</strong></p>
                <p>This ${discussionFormats[discussionState.format].name.toLowerCase()} explored "${discussionState.topic}" through multiple perspectives. Each participant brought their unique viewpoint to create a rich intellectual exchange.</p>
                <p>The discussion highlighted the complexity of the topic and demonstrated how different approaches can lead to valuable insights.</p>
            </div>
        `;
      }
   }
   
   function collectDiscussionContent(arena) {
      const speakers = arena.querySelectorAll('.speaker:not(.moderator-speaker)');
      const exchanges = [];
      
      speakers.forEach(speaker => {
         const name = speaker.querySelector('.speaker-name')?.textContent || 'Speaker';
         const content = speaker.querySelector('.speaker-content')?.textContent || '';
         
         if (content.trim() && !content.includes('Error:') && !content.includes('Loading')) {
            // Limit each exchange to prevent overwhelming the prompt
            const truncatedContent = content.length > 500 ? content.substring(0, 500) + '...' : content;
            exchanges.push(`${name}: ${truncatedContent}`);
         }
      });
      
      // Return last 10 exchanges for context (or all if less than 10)
      return exchanges.slice(-10).join('\n\n');
   }

   // ============================================================================
   // 8. DISCUSSION CONTROL FUNCTIONS
   // ============================================================================

   async function quickShareDiscussion() {
      // Quick share - for anonymous users, just copy the text
      
      // Check if user is authenticated
      if (!currentUser) {
         // For anonymous users, use the text-based share
         shareDiscussion();
         return;
      }

      try {
         // Show loading state on button
         const shareButton = document.querySelector('.share-button');
         const originalText = shareButton.textContent;
         shareButton.textContent = '⏳ Creating share link...';
         shareButton.disabled = true;

         // Collect conversation data
         const conversationData = {
            topic: discussionState.topic,
            format: discussionState.format,
            participants: discussionState.participants.filter(p => p).map(p => p.name),
            conversationData: {
               html: cleanConversationHTML(document.getElementById('discussionArena').innerHTML),
               metadata: {
                  totalExchanges: discussionState.totalExchanges,
                  continuationRound: discussionState.continuationRound,
                  timestamp: new Date().toISOString()
               }
            }
         };

         const response = await fetch('/api/conversations/save', {
            method: 'POST',
            headers: {
               'Content-Type': 'application/json',
               'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify(conversationData)
         });

         const result = await response.json();

         if (response.ok) {
            // Immediately share the conversation
            shareConversation(result.conversationId);
            
            // Update button to show it's been shared
            shareButton.textContent = '✅ Shared!';
            setTimeout(() => {
               shareButton.textContent = originalText;
               shareButton.disabled = false;
            }, 3000);
            
            // Also update save button if it exists
            const saveButton = document.querySelector('.save-button');
            if (saveButton) {
               saveButton.textContent = '✅ Saved';
               saveButton.disabled = true;
               saveButton.style.opacity = '0.7';
            }
         } else {
            throw new Error(result.error || 'Failed to create share link');
         }

      } catch (error) {
         console.error('Quick share error:', error);
         showNotification(`❌ Failed to share: ${error.message}`, 'error');
         
         // Reset button
         const shareButton = document.querySelector('.share-button');
         shareButton.textContent = '📤 Share Conversation';
         shareButton.disabled = false;
      }
   }

   function shareDiscussionHighlight() {
      // Find the most engaging response (longest non-moderator response)
      const speakers = document.querySelectorAll('.speaker:not(.moderator-speaker)');

      if (speakers.length === 0) return;

      // Find best response by length and content quality
      let bestSpeaker = speakers[0];
      let maxLength = 0;

      speakers.forEach(speaker => {
         const content = (speaker.querySelector('.speaker-content') && speaker.querySelector('.speaker-content').textContent) || '';
         const cleanLength = content.replace('📤 Share Quote', '').trim().length;

         if (cleanLength > maxLength && cleanLength > 50) {
            maxLength = cleanLength;
            bestSpeaker = speaker;
         }
      });

      // Share the best response
      shareThisInsight(bestSpeaker.querySelector('.share-insight-btn') || bestSpeaker);
   }

   // Your function with the duplicate innerHTML assignment removed
   function showDiscussionControls() {
      // For chat format, don't show traditional controls
      if (discussionState.format === 'chat') {
         return;
      }

      const controls = document.getElementById('discussionControls');
      // Check if user is approaching limit
      checkAndResetDailyUsage();
      const dailyLimit = 10;
      const remaining = currentUser ? 999 : Math.max(0, dailyLimit - usageState.dailyDiscussions);
      let continueButtonText = "🔄 Continue Discussion";

      if (!usageState.isProUser && remaining <= 1) {
         continueButtonText = `🔄 Continue (${remaining} left total)`;
      }

      // KEEP ONLY ONE innerHTML assignment - remove the duplicate
      controls.innerHTML = `
        <div class="controls-header">
            <h3>💭 Discussion Controls</h3>
        </div>
        <div class="controls-buttons">
            <button class="control-button continue-button" onclick="continueDiscussion()">
                ${continueButtonText}
            </button>
            <button class="control-button share-button" onclick="quickShareDiscussion()">
                📤 Share Conversation
            </button>
            <button class="control-button save-button" onclick="saveDiscussion()">
                💾 Save Discussion
            </button>
            <button class="control-button new-button" onclick="startNewDiscussion()">
                ✨ Start Fresh
            </button>
        </div>
    `;

      controls.classList.add('active');

      // Update continue button text based on progression
      const continueBtn = controls.querySelector('.continue-button');
      if (continueBtn && discussionState.continuationRound > 0) {
         const buttonTexts = [
            "🔄 Continue Discussion",
            "🔍 Go Deeper",
            "🌊 Explore the Depths",
            "✨ Transcend Further",
            "🚀 Beyond Boundaries"
         ];
         const textIndex = Math.min(discussionState.continuationRound, buttonTexts.length - 1);
         continueBtn.innerHTML = buttonTexts[textIndex];
      }

      // Removed auto-scroll to prevent interrupting user's reading
   }

   async function continueDiscussion() {
      // CHECK USAGE LIMITS BEFORE CONTINUING
      checkAndResetDailyUsage();
      const dailyLimit = 10;
      if (!currentUser && usageState.dailyDiscussions >= dailyLimit) {
         trackUpgradeFlow('limit_reached_on_continue', {
            continuationRound: discussionState.continuationRound,
            totalExchanges: discussionState.totalExchanges,
            currentFormat: discussionState.format
         });
         showUpgradeModal();
         return;
      }

      // INCREMENT USAGE COUNTER FOR CONTINUATIONS
      checkAndResetDailyUsage();
      usageState.dailyDiscussions++;
      saveUsageState();
      updateUsageDisplayAdvanced({
    userType: currentUser ? 'authenticated' : 'anonymous',
    isProUser: usageState.isProUser,
    remaining: currentUser ? 'unlimited' : Math.max(0, 10 - usageState.dailyDiscussions)
});

      // NEW: Handle personal chat differently
      if (discussionState.format === 'chat') {
         showUserResponseInput();
         return;
      }

      // Track the continuation as a billable event
      trackEvent('discussion_continued', {
         continuationRound: discussionState.continuationRound + 1,
         format: discussionState.format,
         totalExchanges: discussionState.totalExchanges,
         isProUser: usageState.isProUser,
         dailyDiscussionNumber: usageState.totalDiscussions
      });

      const arena = document.getElementById('discussionArena');
      discussionState.continuationRound++;

      // Determine depth level and progression
      const depthLevel = getDepthLevel(discussionState.continuationRound);
      const roundTitle = getRoundTitle(discussionState.continuationRound, depthLevel);

      // Add continuation header with progression indicators
      const continuationRound = document.createElement('div');
      continuationRound.className = 'discussion-round';
      continuationRound.innerHTML = `
        <div class="phase-indicator">🔄 Round ${discussionState.continuationRound} - ${depthLevel}</div>
        <div class="round-header">${roundTitle}</div>
    `;
      arena.appendChild(continuationRound);

      // Hide controls while continuing
      document.getElementById('discussionControls').classList.remove('active');

      if (discussionState.format === 'arena') {
         await continueArenaDiscussion(arena, discussionState.continuationRound);
      } else {
         await continueMultiPersonDiscussion(arena, discussionState.continuationRound);
      }

      // Show moderator analysis every 2 rounds
      if (discussionState.continuationRound % 2 === 0) {
         await getProgressiveModeratorAnalysis(arena, discussionState.continuationRound);
      }

      // Show helpful hint after round 3
      if (discussionState.continuationRound === 3) {
         showProgressionHint(arena);
      }

      // Show controls again with updated text
      showDiscussionControls();
      moveControlsToBottom();
   }

   function moveControlsToBottom() {
      const controls = document.getElementById('discussionControls');
      const arena = document.getElementById('discussionArena');

      console.log('moveControlsToBottom called');
      console.log('Controls found:', controls);
      console.log('Arena found:', arena);

      if (controls && arena) {
         console.log('Moving controls to bottom...');

         // Remove controls from current position
         controls.remove();

         // Add controls right after the arena (at the very bottom)
         arena.insertAdjacentElement('afterend', controls);

         // Make sure it's visible and scroll to it
         controls.style.display = 'block';
         controls.classList.add('active');

         console.log('Controls moved, scrolling...');

         // Smooth scroll to the new position
         //setTimeout(() => {
         //    controls.scrollIntoView({ 
         //        behavior: 'smooth', 
         //        block: 'center' 
         //    });
         //}, 100);
      } else {
         console.log('Could not move controls - missing elements');
      }
   }

   function getDepthLevel(round) {
      if (round <= 2) return "Building Insights";
      if (round <= 4) return "Questioning Assumptions";
      return "Transcendent Synthesis";
   }

   function getRoundTitle(round, depthLevel) {
      const titles = {
         1: "Expanding on core insights and exploring new angles...",
         2: "Challenging initial assumptions and seeking deeper understanding...",
         3: "Entering philosophical territory and questioning fundamentals...",
         4: "Pursuing transcendent insights beyond conventional thinking...",
         5: "Achieving visionary synthesis of ideas..."
      };
      return titles[round] || "Reaching unprecedented depths of understanding...";
   }

   function showProgressionHint(arena) {
      const hintDiv = document.createElement('div');
      hintDiv.className = 'discussion-round';
      hintDiv.style.background = 'linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%)';
      hintDiv.style.border = '2px solid #4caf50';
      hintDiv.innerHTML = `
        <div class="round-header" style="color: #2e7d32;">💡 Deep Exploration Unlocked</div>
        <div style="padding: 20px; text-align: center; color: #2e7d32;">
            <p><strong>You've reached the philosophical depths!</strong></p>
            <p>Consider exploring a new question or angle to unlock fresh perspectives.</p>
        </div>
    `;
      arena.appendChild(hintDiv);
   }

   async function continueArenaDiscussion(arena, round) {
      const continuationRound = arena.lastElementChild;
      const [figure1, figure2] = discussionState.participants;

      // Collect recent context for smart prompting
      const recentContext = collectRecentContext(arena, 4); // Last 4 exchanges

      // Alternate leadership - let different speakers lead different rounds
      const leader = round % 2 === 1 ? figure1 : figure2;
      const responder = round % 2 === 1 ? figure2 : figure1;

      // Get progressive responses based on depth level
      await getProgressiveContinuationResponse(continuationRound, leader, 'leader', round, recentContext);
      await getProgressiveContinuationResponse(continuationRound, responder, 'responder', round, recentContext);

      // Possible third exchange for deeper rounds
      if (round >= 3) {
         await getProgressiveContinuationResponse(continuationRound, leader, 'synthesis', round, recentContext);
      }

      discussionState.totalExchanges += round >= 3 ? 3 : 2;
   }

   async function continueMultiPersonDiscussion(arena, round) {
      const continuationRound = arena.lastElementChild;
      const validParticipants = discussionState.participants.filter(p => p);
      const recentContext = collectRecentContext(arena, 6); // More context for multi-person

      // Each participant builds on the previous discussion with progressive depth
      for (let i = 0; i < validParticipants.length; i++) {
         await getProgressiveContinuationResponse(continuationRound, validParticipants[i], 'participant', round, recentContext);
      }

      discussionState.totalExchanges += validParticipants.length;
   }

   function collectRecentContext(arena, exchangeLimit) {
      const allSpeakers = arena.querySelectorAll('.speaker:not(.moderator-speaker)');
      const recentSpeakers = Array.from(allSpeakers).slice(-exchangeLimit);

      return recentSpeakers.map(speaker => {
         const name = (speaker.querySelector('.speaker-name') && speaker.querySelector('.speaker-name').textContent) || 'Speaker';
         const content = (speaker.querySelector('.speaker-content') && speaker.querySelector('.speaker-content').textContent) || '';
         return name + ': ' + content.substring(0, 300) + '...';
      }).join('\n\n');
   }

   async function getProgressiveContinuationResponse(container, participant, role, round, recentContext) {
      const speakerDiv = document.createElement('div');
      speakerDiv.className = 'speaker';
      speakerDiv.innerHTML = `
        <div class="speaker-name">${participant.name}</div>
        <div><span class="loading"></span>Exploring deeper insights...</div>
    `;
      container.appendChild(speakerDiv);

      try {
         const formatName = discussionFormats[discussionState.format].name;
         const depthLevel = getDepthLevel(round);

         // Progressive prompt complexity based on round and role
         let prompt = `${participant.prompt}

You are continuing a ${formatName} about: "${discussionState.topic}"

This is Round ${round} - ${depthLevel}. The discussion has evolved significantly.

Recent conversation context:
${recentContext}

${getProgressiveInstructions(round, role)}

Provide a ${getResponseLength(round)} response that demonstrates intellectual growth and deeper understanding.`;

         const response = await callClaude(prompt);

         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div class="speaker-content">${formatResponse(response)}</div>
        `;
         assignSpeakerColor(speakerDiv, participant.name);

      } catch (error) {
         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div>❌ Error: ${error.message}</div>
        `;
      }
   }

   function getProgressiveInstructions(round, role) {
      const instructions = {
         1: {
            leader: "Take the lead in this round. Build meaningfully on the insights shared, introducing fresh angles and deeper considerations.",
            responder: "Respond thoughtfully to the new angles introduced. Add your own insights while weaving together the developing themes.",
            participant: "Build on the established foundation with new insights and perspectives."
         },
         2: {
            leader: "Challenge some of the assumptions that have emerged. Push the discussion toward more fundamental questions.",
            responder: "Engage with the challenges raised. Either defend positions with deeper reasoning or acknowledge valid critiques.",
            participant: "Question assumptions and push toward deeper understanding."
         },
         3: {
            leader: "Enter philosophical territory. Question the very foundations of what we've been discussing.",
            responder: "Meet the philosophical challenge. Explore the deepest implications and fundamental principles.",
            synthesis: "Synthesize the philosophical insights that have emerged. Find the deeper unity or irreconcilable tensions.",
            participant: "Engage philosophically with the fundamental questions raised."
         },
         4: {
            leader: "Seek transcendent insights that go beyond conventional thinking. What wisdom emerges from this deep exploration?",
            responder: "Respond to the transcendent vision. What ultimate insights can you contribute?",
            synthesis: "Achieve a transcendent synthesis. What profound understanding emerges from this entire journey?",
            participant: "Contribute transcendent insights that synthesize our exploration."
         }
      };

      // Special debate instructions for continued engagement
      if (discussionState.format === 'debate') {
         const debateInstructions = {
            1: {
               leader: "Press your advantage from the initial debate. Identify where your opponents showed weakness and exploit those gaps with new evidence and reasoning.",
               responder: "Counter-attack strategically. Address their new points while launching fresh offensive arguments that put pressure on their position.",
               participant: "Continue the intellectual battle. Either press your advantage or fight back against opponent pressure."
            },
            2: {
               leader: "Go deeper into the fundamental weaknesses of the opposing position. Challenge their core assumptions and underlying logic.",
               responder: "Defend your foundational principles while exposing deeper flaws in their reasoning. Show why their entire approach is misguided.",
               participant: "Engage in deeper philosophical combat. Attack or defend the fundamental premises of each position."
            },
            3: {
               leader: "Achieve intellectual superiority by demonstrating the philosophical bankruptcy of their position. Show why your worldview is more coherent.",
               responder: "Mount a final philosophical defense while demonstrating the ultimate contradictions in their thinking.",
               synthesis: "Declare intellectual victory by showing how this entire exchange has proven your position's superiority.",
               participant: "Engage in the highest level of intellectual warfare while maintaining philosophical rigor."
            },
            4: {
               leader: "Demonstrate the transcendent truth of your position. Show how this debate has revealed the deeper wisdom of your stance.",
               responder: "Make a final stand for truth. Show how your position represents higher understanding despite their attacks.",
               synthesis: "Achieve final victory by synthesizing why your position has proven intellectually and philosophically superior throughout this extended engagement.",
               participant: "Fight for the ultimate truth of your position with transcendent reasoning."
            }
         };
         return debateInstructions[Math.min(round, 4)][role] || debateInstructions[Math.min(round, 4)].participant;
      }

      const roundInstructions = instructions[Math.min(round, 4)];
      return roundInstructions[role] || roundInstructions.participant || "Continue the deep exploration with fresh insights.";
   }

   function getResponseLength(round) {
      const lengths = {
         1: "120-150 word",
         2: "130-160 word",
         3: "140-170 word",
         4: "150-180 word"
      };
      return lengths[Math.min(round, 4)] || "150-180 word";
   }

   async function getProgressiveModeratorAnalysis(arena, round) {
      const analysisRound = document.createElement('div');
      analysisRound.className = 'discussion-round';
      analysisRound.style.background = 'linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%)';
      analysisRound.style.border = '2px solid #ff9800';
      analysisRound.innerHTML = `
        <div class="round-header" style="color: #e65100;">📊 Moderator Analysis - Round ${round}</div>
    `;
      arena.appendChild(analysisRound);

      const moderatorDiv = document.createElement('div');
      moderatorDiv.className = 'speaker moderator-speaker';
      moderatorDiv.innerHTML = `
        <div class="speaker-name">🎓 Deep Analysis</div>
        <div><span class="loading"></span>Analyzing the progression...</div>
    `;
      analysisRound.appendChild(moderatorDiv);

      try {
         const validParticipants = discussionState.participants.filter(p => p);
         const participantNames = validParticipants.map(p => p.name).join(' and ');
         const recentContext = collectRecentContext(arena, 8);

         const prompt = `You are providing deep analysis of an ongoing discussion about "${discussionState.topic}" between ${participantNames}.

This is Round ${round} analysis. The discussion has progressed through ${round} continuation rounds with ${discussionState.totalExchanges} total exchanges.

Recent progression:
${recentContext}

Provide insightful analysis (150-200 words) that:
- Identifies how the thinking has evolved and deepened
- Highlights breakthrough insights or turning points
- Notes the intellectual trajectory and emerging patterns
- Suggests what profound directions might emerge next
- Celebrates the depth achieved so far

Be philosophical and inspiring while maintaining analytical rigor.`;

         const response = await callClaude(prompt);

         moderatorDiv.innerHTML = `
            <div class="speaker-name">🎓 Deep Analysis</div>
            <div class="speaker-content">${formatModeratorResponse(response)}</div>
        `;

      } catch (error) {
         moderatorDiv.innerHTML = `
            <div class="speaker-name">🎓 Deep Analysis</div>
            <div>📈 The discussion continues to evolve with remarkable depth and insight. Each round reveals new layers of understanding.</div>
        `;
      }
   }

   async function getBriefModeratorUpdate(container) {
      const moderatorDiv = document.createElement('div');
      moderatorDiv.className = 'speaker moderator-speaker';
      moderatorDiv.innerHTML = `
        <div class="speaker-name">🎓 Moderator Update</div>
        <div><span class="loading"></span>Noting new insights...</div>
    `;
      container.appendChild(moderatorDiv);

      try {
         const validParticipants = discussionState.participants.filter(p => p);
         const participantNames = validParticipants.map(p => p.name).join(' and ');

         const prompt = `You are moderating an ongoing discussion about "${discussionState.topic}" with ${participantNames}.

They just provided follow-up thoughts that built on their previous conversation. Provide a brief update (50-80 words) that:
- Acknowledges the new insights shared
- Notes how the discussion has evolved
- Highlights any emerging themes

Keep it concise and forward-looking.`;

         const response = await callClaude(prompt);

         moderatorDiv.innerHTML = `
            <div class="speaker-name">🎓 Moderator Update</div>
            <div class="speaker-content">${formatModeratorResponse(response)}</div>
        `;

      } catch (error) {
         moderatorDiv.innerHTML = `
            <div class="speaker-name">🎓 Moderator Update</div>
            <div>📝 The discussion continues to evolve with new insights and perspectives.</div>
        `;
      }
   }

   function startNewDiscussion() {
      // Reset discussion state
      discussionState = {
         format: 'arena',
         participantCount: 2,
         participants: [],
         topic: '',
         responses: [],
         continuationRound: 0,
         totalExchanges: 0
      };

      // Hide discussion areas
      document.getElementById('discussionArena').style.display = 'none';
      document.getElementById('discussionControls').classList.remove('active');

      // SHOW all the main sections that should be visible on homepage
      document.querySelectorAll('.topics-container, .speaker-selection-main, .format-selection-main, .question-section-main').forEach(el => {
         el.style.display = 'block';
      });

      // Reset forms and selections
      document.querySelectorAll('.ai-speaker-card').forEach(card => card.classList.remove('selected'));
      document.getElementById('userQuestionInput').value = '';

      // Clear selected speakers display
      const selectedSpeakers = document.getElementById('selectedSpeakers');
      if (selectedSpeakers) {
         const selectedList = document.getElementById('selectedList');
         const selectedTitle = document.getElementById('selectedSpeakersTitle');

         if (selectedList) {
            selectedList.innerHTML = '<p style="color: #6c757d; font-style: italic;">No speakers selected yet</p>';
         }

         if (selectedTitle) {
            selectedTitle.textContent = 'Selected Speakers (0/2):';
         }
      }

      // Reset selected speakers array
      if (window.selectedAISpeakers) {
         window.selectedAISpeakers = [];
      }

      // Hide AI suggestions section
      const aiSection = document.getElementById('aiSuggestionSection');
      if (aiSection) {
         aiSection.style.display = 'none';
      }

      // Reset topic selections
      document.querySelectorAll('.topic-type-slim').forEach(el => {
         el.classList.remove('selected');
      });

      // Reset format selections
      document.querySelectorAll('.format-type-small').forEach(el => {
         el.classList.remove('selected');
      });
      // Select default format (arena)
      const arenaElement = document.querySelector('[data-format="arena"]');
      arenaElement && arenaElement.classList.add('selected');

      // Disable AI suggestions button
      const aiButton = document.getElementById('aiSuggestionsBtn');
      if (aiButton) {
         aiButton.disabled = true;
         aiButton.style.opacity = '0.5';
      }

      // Reset any demo or global state
      selectedTopic = null;

      // Scroll to top
      window.scrollTo({
         top: 0,
         behavior: 'smooth'
      });
   }

   // Function to clean HTML before saving (removes interactive elements)
   function cleanConversationHTML(html) {
      // Create a temporary container
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      
      // Remove all buttons and interactive elements
      const elementsToRemove = tempDiv.querySelectorAll('.interject-btn, .share-quote-btn, button');
      elementsToRemove.forEach(elem => elem.remove());
      
      // Remove any speaker-actions divs that might contain buttons
      const speakerActions = tempDiv.querySelectorAll('.speaker-actions');
      speakerActions.forEach(elem => elem.remove());
      
      return tempDiv.innerHTML;
   }

   async function saveDiscussion() {
      // Check if user is pro
      const isProUser = currentUser && currentUser.isProUser;
      if (!isProUser) {
         showUpgradeForFeature('save');
         return;
      }

      try {
         // Collect conversation data
         const conversationData = {
            topic: discussionState.topic,
            format: discussionState.format,
            participants: discussionState.participants.filter(p => p).map(p => p.name),
            conversationData: {
               html: cleanConversationHTML(document.getElementById('discussionArena').innerHTML),
               metadata: {
                  totalExchanges: discussionState.totalExchanges,
                  continuationRound: discussionState.continuationRound,
                  timestamp: new Date().toISOString()
               }
            }
         };

         const response = await fetch('/api/conversations/save', {
            method: 'POST',
            headers: {
               'Content-Type': 'application/json',
               'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify(conversationData)
         });

         const result = await response.json();

         if (response.ok) {
            showNotification('💾 Conversation saved successfully!', 'success');
            
            // Change button to show it's been saved
            const saveButton = document.querySelector('.save-button');
            if (saveButton) {
               saveButton.textContent = '✅ Saved';
               saveButton.disabled = true;
               saveButton.style.opacity = '0.7';
            }
         } else {
            throw new Error(result.error || 'Failed to save conversation');
         }

      } catch (error) {
         console.error('Save error:', error);
         showNotification(`❌ Failed to save conversation: ${error.message}`, 'error');
      }
   }

   function shareConversation(conversationId) {
      // Create shareable link
      const shareUrl = `${window.location.origin}/conversation.html?id=${conversationId}`;
      const shareMessage = `Check out this fascinating discussion on Iconoclash!\n\n${shareUrl}\n\nEngage with history's greatest thinkers at iconoclash.ai`;
      
      // Get the share button that was clicked
      const shareButton = document.querySelector('.share-button');
      const originalText = shareButton ? shareButton.textContent : '';
      
      // Copy to clipboard
      navigator.clipboard.writeText(shareMessage).then(() => {
         showNotification(`📋 Share link copied to clipboard!`, 'success');
         
         // Update button text to show it was copied
         if (shareButton) {
            shareButton.textContent = '✅ Link Saved to Clipboard';
            shareButton.style.background = '#4caf50';
            
            // Reset after 3 seconds
            setTimeout(() => {
               shareButton.textContent = originalText;
               shareButton.style.background = '';
            }, 3000);
         }
      }).catch(() => {
         // Fallback for older browsers
         const textArea = document.createElement('textarea');
         textArea.value = shareMessage;
         textArea.style.position = 'fixed';
         textArea.style.opacity = '0';
         document.body.appendChild(textArea);
         textArea.select();
         document.execCommand('copy');
         document.body.removeChild(textArea);
         
         showNotification(`📋 Share link copied to clipboard!`, 'success');
         
         // Update button text
         if (shareButton) {
            shareButton.textContent = '✅ Link Saved to Clipboard';
            shareButton.style.background = '#4caf50';
            
            setTimeout(() => {
               shareButton.textContent = originalText;
               shareButton.style.background = '';
            }, 3000);
         }
      });
   }

   function shareDiscussion() {
      try {
         const participants = discussionState.participants.filter(p => p).map(p => p.name).join(' & ');
         const formatName = discussionFormats[discussionState.format].name;

         // Extract key discussion points
         const speakers = document.querySelectorAll('.speaker:not(.moderator-speaker)');
         let discussionSummary = `${formatName}: "${discussionState.topic}"\nParticipants: ${participants}\n\n`;

         // Add key excerpts (first 100 chars from each speaker)
         speakers.forEach((speaker, index) => {
            if (index < 6) { // Limit to first 6 responses
               const name = (speaker.querySelector('.speaker-name') && speaker.querySelector('.speaker-name').textContent) || 'Speaker';
               const content = (speaker.querySelector('.speaker-content') && speaker.querySelector('.speaker-content').textContent) || '';
               const excerpt = content.substring(0, 120).trim();
               if (excerpt) {
                  discussionSummary += `${name}: ${excerpt}${content.length > 120 ? '...' : ''}\n\n`;
               }
            }
         });

         discussionSummary += `\nGenerated by Iconoclash Discussion Arena\niconoclash.ai`;

         // Check if Web Share API is available (better for mobile)
         if (navigator.share && navigator.canShare && navigator.canShare({ text: discussionSummary })) {
            // Use native share on mobile devices
            navigator.share({
               title: 'Iconoclash Discussion',
               text: discussionSummary
            }).then(() => {
               showNotification('✅ Discussion shared!', 'success');
            }).catch((error) => {
               // User cancelled share, no need to show error
               if (error.name !== 'AbortError') {
                  console.error('Share failed:', error);
                  fallbackShare(discussionSummary);
               }
            });
         } else {
            // Fallback to clipboard copy
            fallbackShare(discussionSummary);
         }

      } catch (error) {
         showNotification('❌ Failed to share discussion', 'error');
         console.error('Share error:', error);
      }
   }

   function fallbackShare(text) {
      navigator.clipboard.writeText(text).then(() => {
         showNotification('🔗 Discussion copied to clipboard!', 'success');
      }).catch(() => {
         // Fallback for older browsers
         const textArea = document.createElement('textarea');
         textArea.value = text;
         textArea.style.position = 'fixed';
         textArea.style.opacity = '0';
         document.body.appendChild(textArea);
         textArea.select();
         document.execCommand('copy');
         document.body.removeChild(textArea);
         showNotification('🔗 Discussion copied to clipboard!', 'success');
      });
   }

   // Extract conversation data from the current discussion
   function extractConversationData() {
      const arena = document.getElementById('discussionArena');
      if (!arena) return null;

      const messages = [];
      const speakers = arena.querySelectorAll('.speaker');

      speakers.forEach((speakerElement, index) => {
         const nameElement = speakerElement.querySelector('.speaker-name');
         const contentElement = speakerElement.querySelector('.speaker-content');

         if (nameElement && contentElement) {
            const speakerName = nameElement.textContent.trim();
            // Get clean text content without buttons
            const content = extractCleanContent(contentElement);

            if (content && content.length > 10) { // Only save substantial content
               messages.push({
                  speaker: speakerName,
                  content: content,
                  timestamp: new Date().toISOString(),
                  order: index
               });
            }
         }
      });

      return {
         messages: messages,
         metadata: {
            totalExchanges: discussionState.totalExchanges || messages.length,
            continuationRounds: discussionState.continuationRound || 0,
            format: discussionState.format,
            topic: discussionState.topic,
            startTime: new Date().toISOString() // We don't track actual start time, so use current
         }
      };
   }

   // Extract clean text content without action buttons
   function extractCleanContent(contentElement) {
      // Clone the element so we don't modify the original
      const clone = contentElement.cloneNode(true);

      // Remove action buttons
      const buttons = clone.querySelectorAll('.speaker-actions, .interject-btn, button');
      buttons.forEach(button => button.remove());

      // Get the clean text
      return clone.textContent.trim();
   }

   // Save conversation function
   async function saveConversation() {
      // Check if user is authenticated
      if (!currentUser) {
         showNotification('Please sign up or log in to save conversations', 'info');
         showSignup();
         return;
      }

      // Check if there's a conversation to save
      if (!discussionState.participants || discussionState.participants.length === 0) {
         showNotification('No conversation to save', 'info');
         return;
      }

      const conversationData = extractConversationData();
      if (!conversationData || conversationData.messages.length === 0) {
         showNotification('No conversation content to save', 'info');
         return;
      }

      // Show saving state
      const saveButton = document.querySelector('.save-button');
      if (saveButton) {
         saveButton.textContent = '💾 Saving...';
         saveButton.disabled = true;
      }

      try {
         const response = await fetch('/api/conversations/save', {
            method: 'POST',
            headers: {
               'Content-Type': 'application/json',
               'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
               topic: discussionState.topic,
               format: discussionState.format,
               participants: discussionState.participants.map(p => p.name),
               conversationData: conversationData
            })
         });

         const result = await response.json();

         if (response.ok) {
            showNotification(`✅ Saved as "${result.title}"`, 'success');

            // Track the save
            trackEvent('conversation_saved', {
               conversationId: result.conversationId,
               format: discussionState.format,
               participantCount: discussionState.participants.length,
               messageCount: conversationData.messages.length
            });
         } else {
            throw new Error(result.error || 'Failed to save conversation');
         }

      } catch (error) {
         console.error('Save conversation error:', error);
         showNotification('❌ Failed to save conversation', 'error');
      } finally {
         // Restore save button
         if (saveButton) {
            saveButton.textContent = '💾 Save Discussion';
            saveButton.disabled = false;
         }
      }
   }

   // Show user's saved conversations (we'll build this UI later)
   async function showSavedConversations() {
      if (!currentUser) {
         showNotification('Please sign up or log in to view saved conversations', 'info');
         return;
      }

      try {
         const response = await fetch('/api/conversations', {
            headers: {
               'Authorization': `Bearer ${authToken}`
            }
         });

         const conversations = await response.json();

         if (response.ok) {
            displayConversationsModal(conversations);
         } else {
            throw new Error(conversations.error || 'Failed to fetch conversations');
         }

      } catch (error) {
         console.error('Fetch conversations error:', error);
         showNotification('❌ Failed to load conversations', 'error');
      }
   }

   // Display conversations in a modal (simple version for now)
   function displayConversationsModal(conversations) {
      // Remove existing modal
      const existingModal = document.querySelector('.conversations-modal');
      if (existingModal) existingModal.remove();

      const modal = document.createElement('div');
      modal.className = 'conversations-modal';
      modal.innerHTML = `
        <div class="conversations-content">
            <div class="conversations-header">
                <h2>📚 Your Saved Conversations</h2>
                <button class="close-conversations" onclick="closeConversationsModal()">✕</button>
            </div>
            
            <div class="conversations-list">
                ${conversations.length === 0 ? `
                    <div class="no-conversations">
                        <p>No saved conversations yet.</p>
                        <p>Start a discussion and save it to build your library!</p>
                    </div>
                ` : conversations.map(conv => `
                    <div class="conversation-item" data-id="${conv.id}">
                        <div class="conversation-main">
                            <h3 class="conversation-title">${conv.title}</h3>
                            <div class="conversation-meta">
                                <span class="conversation-format">${getFormatIcon(conv.format)} ${conv.format}</span>
                                <span class="conversation-participants">${JSON.parse(conv.participants).join(', ')}</span>
                                <span class="conversation-date">${formatDate(conv.created_at)}</span>
                            </div>
                            <div class="conversation-topic">"${conv.topic}"</div>
                        </div>
                        
                        <div class="conversation-actions">
                            <button class="action-btn view-btn" onclick="viewConversation(${conv.id})">
                                👁️ View
                            </button>
                            <button class="action-btn share-btn" onclick="shareConversation(${conv.id})">
                                🔗 Share
                            </button>
                            <button class="action-btn delete-btn" onclick="deleteConversation(${conv.id})">
                                🗑️ Delete
                            </button>
                        </div>
                    </div>
                `).join('')}
            </div>
            
            <div class="conversations-footer">
                <button class="conversations-close-btn" onclick="closeConversationsModal()">
                    Close
                </button>
            </div>
        </div>
    `;

      document.body.appendChild(modal);
   }

   function closeConversationsModal() {
      const modal = document.querySelector('.conversations-modal');
      if (modal) modal.remove();
   }

   function formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {
         hour: '2-digit',
         minute: '2-digit'
      });
   }

   async function viewConversation(conversationId) {
      try {
         const response = await fetch(`/api/conversations/${conversationId}`, {
            headers: {
               'Authorization': `Bearer ${authToken}`
            }
         });

         const conversation = await response.json();

         if (response.ok) {
            displayConversationViewer(conversation);
         } else {
            throw new Error(conversation.error || 'Failed to load conversation');
         }
      } catch (error) {
         console.error('View conversation error:', error);
         showNotification('❌ Failed to load conversation', 'error');
      }
   }

   function displayConversationViewer(conversation) {
      // Hide main app sections
      document.querySelectorAll('.format-selection, .speaker-selection, .question-section, #discussionArena, #discussionControls').forEach(el => {
         el.style.display = 'none';
      });

      // Close conversations modal
      closeConversationsModal();

      // Create viewer
      const viewer = document.createElement('div');
      viewer.className = 'conversation-viewer';
      viewer.innerHTML = `
        <div class="viewer-header">
            <div class="viewer-title">
                <h2>${conversation.title}</h2>
                <div class="viewer-meta">
                    <span>${getFormatIcon(conversation.format)} ${conversation.format}</span>
                    <span>📅 ${formatDate(conversation.created_at)}</span>
                    <span>👥 ${conversation.participants.join(', ')}</span>
                </div>
            </div>
            <div class="viewer-actions">
                <button class="viewer-btn share-btn" onclick="shareConversation(${conversation.id})">
                    🔗 Share
                </button>
                <button class="viewer-btn back-btn" onclick="closeConversationViewer()">
                    ← Back to App
                </button>
            </div>
        </div>
        
        <div class="viewer-content">
            ${conversation.conversation_data.html}
        </div>
    `;

      // Insert viewer into container
      const container = document.querySelector('.container .content') || document.querySelector('.container');
      container.appendChild(viewer);
   }

   function closeConversationViewer() {
      const viewer = document.querySelector('.conversation-viewer');
      if (viewer) viewer.remove();

      // Show main app sections
      document.querySelectorAll('.format-selection, .speaker-selection, .question-section').forEach(el => {
         el.style.display = 'block';
      });
   }

   async function shareConversation(conversationId) {
      try {
         // For now, create a simple shareable URL
         const shareUrl = `${window.location.origin}/conversation/${conversationId}`;

         if (navigator.share && navigator.canShare({
               url: shareUrl
            })) {
            await navigator.share({
               title: 'Iconoclash Conversation',
               text: 'Check out this fascinating discussion on Iconoclash!',
               url: shareUrl
            });
         } else {
            // Fallback to clipboard
            await navigator.clipboard.writeText(shareUrl);
            showNotification('🔗 Share link copied to clipboard!', 'success');
         }

      } catch (error) {
         console.error('Share error:', error);
         showNotification('❌ Failed to create share link', 'error');
      }
   }

   async function deleteConversation(conversationId) {
      if (!confirm('Are you sure you want to delete this conversation? This cannot be undone.')) {
         return;
      }

      try {
         const response = await fetch(`/api/conversations/${conversationId}`, {
            method: 'DELETE',
            headers: {
               'Authorization': `Bearer ${authToken}`
            }
         });

         const result = await response.json();

         if (response.ok) {
            showNotification('🗑️ Conversation deleted', 'success');

            // Remove from UI
            const conversationItem = document.querySelector(`[data-id="${conversationId}"]`);
            if (conversationItem) {
               conversationItem.remove();
            }
         } else {
            throw new Error(result.error || 'Failed to delete conversation');
         }
      } catch (error) {
         console.error('Delete error:', error);
         showNotification('❌ Failed to delete conversation', 'error');
      }
   }


   // ============================================================================
   // 9. API FUNCTIONS
   // ============================================================================

   // ============================================================================
   // 10. EVENT LISTENERS AND INITIALIZATION
   // ============================================================================

   // Initialize the application
   // Initialize the app when page loads
   // Close modal when clicking outside (with null check)
   document.addEventListener('DOMContentLoaded', function () {
      // ============================================================================
      // APP STATE INITIALIZATION
      // ============================================================================
      // Set default state
      discussionState.format = 'arena';
      discussionState.participantCount = 2;
      selectedAISpeakers = [];
      
      // FORCE PRO STATUS FOR LOCAL TESTING
      usageState.isProUser = true;
      usageState.totalDiscussions = 0;
      
      // Force update the UI to show Pro status
      setTimeout(() => {
         // Update auth UI to show pro controls
         updateAuthUI();
         
         // Also update if updateUsageDisplayAdvanced exists
         if (typeof updateUsageDisplayAdvanced === 'function') {
            updateUsageDisplayAdvanced({
               userType: currentUser ? 'authenticated' : 'anonymous',
               isProUser: true,
               remaining: 999
            });
         }
      }, 100);

      // ============================================================================
      // AUTHENTICATION INITIALIZATION
      // ============================================================================
      initializeAuth();
      checkExistingAuth();
      
      // Update format display based on initial auth state
      setTimeout(() => {
         updateFormatDisplay();
      }, 500);

      // Auth modal click outside to close (with null check)
      const authModal = document.getElementById('authModal');
      if (authModal) {
         authModal.addEventListener('click', function (e) {
            if (e.target === this) {
               closeAuthModal();
            }
         });
      }

      // ============================================================================
      // INPUT HANDLERS INITIALIZATION
      // ============================================================================
      // Initialize all the input handlers
      initializeCustomSpeakerInput();
      initializeQuestionInput();
      initializeCustomTopicInput();

      // ============================================================================
      // DISPLAY AND UI INITIALIZATION
      // ============================================================================
      // Update initial display
      updateAllDisplays();

      // ============================================================================
      // USAGE AND ANALYTICS INITIALIZATION
      // ============================================================================
      initializeUsageTracking();
      initializeAnalytics();
      checkPaymentSuccess();
      
      // FORCE PRO STATUS AFTER ALL INITIALIZATION
      setTimeout(() => {
         usageState.isProUser = true;
         usageState.totalDiscussions = 0;
         saveUsageState();
         
         // Force update all UI elements
         updateAuthUI();
         
         // Update usage display if not logged in
         if (!currentUser) {
            userWelcome.textContent = 'Unlimited Pro (Testing Mode)';
         }
      }, 500);

      // ============================================================================
      // FINAL SETUP
      // ============================================================================
      // Initialize AI suggestions button state
      checkAISuggestionsReadiness();
   });


   function initializeAuth() {
      // Check for stored auth token
      authToken = localStorage.getItem('authToken');

      if (authToken) {
         // Verify token with server
         fetch('/api/auth/me', {
               headers: {
                  'Authorization': `Bearer ${authToken}`
               }
            })
            .then(response => {
               if (response.ok) {
                  return response.json();
               } else {
                  // Token invalid, clear it
                  localStorage.removeItem('authToken');
                  authToken = null;
                  throw new Error('Invalid token');
               }
            })
            .then(user => {
               currentUser = user;
               updateAuthUI();
            })
            .catch(error => {
               console.log('Auth check failed:', error);
               updateAuthUI();
            });
      } else {
         updateAuthUI();
      }
   }

   function updateFormatDisplay() {
      // Update format display based on user status
      const premiumFormats = document.querySelectorAll('.premium-format');
      const isProUser = currentUser && currentUser.isProUser;
      
      premiumFormats.forEach(format => {
         const badge = format.querySelector('.premium-badge');
         if (isProUser) {
            // Remove PRO badge and overlay for pro users
            if (badge) badge.style.display = 'none';
            format.classList.remove('premium-format');
         } else {
            // Show PRO badge for non-pro users
            if (badge) badge.style.display = 'inline-block';
            format.classList.add('premium-format');
         }
      });
   }

   function updateAuthUI() {
      const anonymousControls = document.getElementById('anonymousControls');
      const freeUserControls = document.getElementById('freeUserControls');
      const proUserControls = document.getElementById('proUserControls');
      const usageIndicator = document.getElementById('usageIndicator');

      // Hide all control groups first
      anonymousControls.style.display = 'none';
      freeUserControls.style.display = 'none';
      proUserControls.style.display = 'none';

      if (currentUser) {
         // User is logged in
         // SYNC SERVER DISCUSSION COUNT TO CLIENT STATE
         usageState.totalDiscussions = currentUser.discussionsUsed || 0;
         usageState.isProUser = currentUser.isProUser || false;
         saveUsageState();

         if (currentUser.isProUser) {
            // Pro user
            proUserControls.style.display = 'flex';
            // Hide usage indicator for pro users (they have unlimited)
            usageIndicator.style.display = 'none';
         } else {
            // This shouldn't happen in new model - all logged in users are pro
            freeUserControls.style.display = 'flex';
            usageIndicator.style.display = 'none';
         }
      } else {
         // User is not logged in - show anonymous state
         anonymousControls.style.display = 'flex';
         
         // Show anonymous usage
         checkAndResetDailyUsage();
         const remaining = Math.max(0, 10 - usageState.dailyDiscussions);
         usageIndicator.innerHTML = `${remaining} free today`;
         usageIndicator.className = remaining <= 2 ? 'usage-indicator low' : 'usage-indicator';
         usageIndicator.style.display = 'block';
      }
      
      // Update format display based on user status
      updateFormatDisplay();
   }

   function checkProAccessForConversations() {
      const isProUser = currentUser && currentUser.isProUser;
      if (isProUser) {
         window.location.href = '/conversations.html';
      } else {
         showUpgradeForFeature('conversations');
      }
   }

   function showUpgradeForFeature(feature) {
      const messages = {
         save: 'Save your conversations and access them anytime',
         conversations: 'View all your saved conversations',
         format: 'Unlock all discussion formats',
         default: 'Get unlimited conversations and premium features'
      };
      
      const message = messages[feature] || messages.default;
      
      // Update upgrade modal content
      const modal = document.getElementById('upgradeModal');
      if (modal) {
         const featureText = modal.querySelector('.upgrade-feature-text');
         if (featureText) {
            featureText.textContent = message;
         }
      }
      
      showUpgradeModal();
   }

   // Modal functions
   function showLogin() {
      document.getElementById('authModal').classList.add('show');
      document.getElementById('loginForm').style.display = 'block';
      document.getElementById('signupForm').style.display = 'none';
      clearAuthErrors();
   }

   function showSignup() {
      document.getElementById('authModal').classList.add('show');
      document.getElementById('loginForm').style.display = 'none';
      document.getElementById('signupForm').style.display = 'block';
      clearAuthErrors();
   }

   function closeAuthModal() {
      document.getElementById('authModal').classList.remove('show');
      clearAuthErrors();
   }

   function switchToSignup() {
      document.getElementById('loginForm').style.display = 'none';
      document.getElementById('signupForm').style.display = 'block';
      clearAuthErrors();
   }

   function switchToLogin() {
      document.getElementById('loginForm').style.display = 'block';
      document.getElementById('signupForm').style.display = 'none';
      clearAuthErrors();
   }

   function clearAuthErrors() {
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('signupError').style.display = 'none';
      document.getElementById('signupSuccess').style.display = 'none';
   }

   // Auth API calls
   async function handleLogin(event) {
      event.preventDefault();

      const email = document.getElementById('loginEmail').value;
      const password = document.getElementById('loginPassword').value;
      const submitBtn = document.getElementById('loginSubmit');
      const errorDiv = document.getElementById('loginError');

      submitBtn.disabled = true;
      submitBtn.textContent = 'Signing in...';

      try {
         const response = await fetch('/api/auth/login', {
            method: 'POST',
            headers: {
               'Content-Type': 'application/json'
            },
            body: JSON.stringify({
               email,
               password
            })
         });

         const data = await response.json();

         if (response.ok) {
            // Success
            authToken = data.token;
            currentUser = data.user;
            localStorage.setItem('authToken', authToken);

            updateAuthUI();
            closeAuthModal();
            showNotification('Welcome back!', 'success');
         } else {
            // Error
            errorDiv.textContent = data.error;
            errorDiv.style.display = 'block';
         }
      } catch (error) {
         errorDiv.textContent = 'Network error. Please try again.';
         errorDiv.style.display = 'block';
      }

      submitBtn.disabled = false;
      submitBtn.textContent = 'Sign In';
   }

   async function handleSignup(event) {
      event.preventDefault();

      const email = document.getElementById('signupEmail').value;
      const password = document.getElementById('signupPassword').value;
      const submitBtn = document.getElementById('signupSubmit');
      const errorDiv = document.getElementById('signupError');
      const successDiv = document.getElementById('signupSuccess');

      submitBtn.disabled = true;
      submitBtn.textContent = 'Creating account...';

      try {
         const response = await fetch('/api/auth/register', {
            method: 'POST',
            headers: {
               'Content-Type': 'application/json'
            },
            body: JSON.stringify({
               email,
               password
            })
         });

         const data = await response.json();

         if (response.ok) {
            // Success
            authToken = data.token;
            currentUser = data.user;
            localStorage.setItem('authToken', authToken);

            updateAuthUI();
            closeAuthModal();
            showNotification('Account created! Welcome to Iconoclash!', 'success');
         } else {
            // Error
            errorDiv.textContent = data.error;
            errorDiv.style.display = 'block';
         }
      } catch (error) {
         errorDiv.textContent = 'Network error. Please try again.';
         errorDiv.style.display = 'block';
      }

      submitBtn.disabled = false;
      submitBtn.textContent = 'Create Account';
   }

   function logout() {
      authToken = null;
      currentUser = null;
      localStorage.removeItem('authToken');
      updateAuthUI();
      showNotification('Logged out successfully', 'info');
   }

   // Add this to your existing code
   async function checkExistingAuth() {
      const token = localStorage.getItem('authToken');
      if (token) {
         try {
            const response = await fetch('/api/auth/me', {
               headers: {
                  'Authorization': `Bearer ${token}`
               }
            });

            if (response.ok) {
               const userData = await response.json();
               authToken = token;
               currentUser = userData;
               updateAuthUI();
            } else {
               // Token expired or invalid
               logout();
            }
         } catch (error) {
            console.error('Auth check failed:', error);
            logout();
         }
      }
   }

   // Update your existing callClaude function to include auth
   async function callClaude(prompt, isSuggestion = false) {
      const headers = {
         'Content-Type': 'application/json'
      };

      if (authToken) {
         headers['Authorization'] = `Bearer ${authToken}`;
      }

      const response = await fetch('/api/claude', {
         method: 'POST',
         headers: headers,
         body: JSON.stringify({
            message: prompt,
            figure: 'discussion',
            isSuggestion: isSuggestion,
            discussionId: discussionState.discussionId
         })
      });

      if (!response.ok) {
         const errorData = await response.json();

         // TEMPORARILY DISABLED FOR LOCAL TESTING
         /*
         if (response.status === 429 && errorData.limit) {
            // Usage limit reached
            if (!currentUser) {
               showSignup();
               throw new Error('Please sign up to continue discussions');
            } else {
               showUpgradeModal();
               throw new Error('Free discussion limit reached');
            }
         }
         */

         throw new Error(`API Error: ${response.status} - ${errorData.error || 'Unknown error'}`);
      }

      const data = await response.json();

      // Update usage display if we have usage info
      if (data.usage) {
         updateUsageDisplayAdvanced({
            userType: currentUser ? 'authenticated' : 'anonymous',
            isProUser: usageState.isProUser,
            remaining: currentUser ? Math.max(0, 10 - usageState.dailyDiscussions) : Math.max(0, 10 - usageState.dailyDiscussions)
         });
      }

      return data.content[0].text;
   }


   function initializeQuestionInput() {
      const userQuestionInput = document.getElementById('userQuestionInput');

      if (!userQuestionInput) return;

      userQuestionInput.addEventListener('input', function () {
         updateStartButtonState();
      });
   }

   function updateAllDisplays() {
      updateSelectedSpeakerDisplay();
      updateStartButtonState();
   }

   function updateStartButtonState() {
      const startBtn = document.getElementById('startDiscussionBtn');
      const helpText = document.querySelector('.start-help-text');
      const speakersNeeded = document.getElementById('speakersNeeded');
      const userQuestionInput = document.getElementById('userQuestionInput');

      if (!startBtn || !userQuestionInput) return; // Safety check

      const hasEnoughSpeakers = selectedAISpeakers.length === discussionState.participantCount;
      const hasQuestion = userQuestionInput.value.trim().length > 10;

      // Update speakers needed display
      if (speakersNeeded) {
         speakersNeeded.textContent = discussionState.participantCount - selectedAISpeakers.length;
      }

      if (hasEnoughSpeakers && hasQuestion) {
         startBtn.disabled = false;
         startBtn.textContent = `🚀 Start ${discussionFormats[discussionState.format].name}`;
         if (helpText) helpText.style.display = 'none';
      } else {
         startBtn.disabled = true;
         if (!hasEnoughSpeakers && !hasQuestion) {
            startBtn.textContent = `Select ${discussionState.participantCount - selectedAISpeakers.length} more speaker${discussionState.participantCount - selectedAISpeakers.length !== 1 ? 's' : ''} and enter a question`;
         } else if (!hasEnoughSpeakers) {
            startBtn.textContent = `Select ${discussionState.participantCount - selectedAISpeakers.length} more speaker${discussionState.participantCount - selectedAISpeakers.length !== 1 ? 's' : ''}`;
         } else {
            startBtn.textContent = 'Enter a question to start';
         }
         if (helpText) helpText.style.display = 'block';
      }
   }


   function removeSpeaker(speakerName) {
      const index = selectedAISpeakers.findIndex(s => s.name === speakerName);
      if (index !== -1) {
         selectedAISpeakers.splice(index, 1);
         updateAllDisplays();
         checkAISuggestionsReadiness();

         // Track speaker removal
         trackEvent('speaker_removed', {
            speakerName: speakerName,
            remainingCount: selectedAISpeakers.length
         });
      }
   }

   function showChatInputWithControls() {
      const arena = document.getElementById('discussionArena');
      
      // Create a container for both input and controls
      const chatContainer = document.createElement('div');
      chatContainer.className = 'chat-continuation-container';
      
      // Create user input interface
      const userInputDiv = document.createElement('div');
      userInputDiv.className = 'user-response-input';
      userInputDiv.innerHTML = `
        <div class="user-input-header">
            <h4>💬 Your Response</h4>
        </div>
        <textarea id="userChatResponse" placeholder="Type your message..." oninput="updateChatSendButton()"></textarea>
        <div class="user-input-actions">
            <button id="chatSendButton" onclick="submitUserChatResponse()" disabled>Send</button>
        </div>
      `;
      
      // Create limited discussion controls for chat
      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'chat-controls';
      controlsDiv.innerHTML = `
        <div class="controls-buttons">
            <button class="control-button share-button" onclick="quickShareDiscussion()">
                📤 Share Conversation
            </button>
            <button class="control-button save-button" onclick="saveDiscussion()">
                💾 Save Discussion
            </button>
            <button class="control-button new-button" onclick="startNewDiscussion()">
                ✨ Start Fresh
            </button>
        </div>
      `;
      
      chatContainer.appendChild(userInputDiv);
      chatContainer.appendChild(controlsDiv);
      arena.appendChild(chatContainer);
      
      // Scroll to input
      userInputDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // Focus on textarea
      setTimeout(() => {
         const textarea = document.getElementById('userChatResponse');
         if (textarea) {
            textarea.focus();
         }
      }, 100);
   }

   function showUserResponseInput() {
      // Check usage limits
      checkAndResetDailyUsage();
      const dailyLimit = 10;
      if (!currentUser && usageState.dailyDiscussions >= dailyLimit) {
         showUpgradeModal();
         return;
      }

      // Hide discussion controls
      const controls = document.getElementById('discussionControls');
      if (controls) {
         controls.classList.remove('active');
      }

      // Show chat input with integrated controls
      showChatInputWithControls();
   }

   // Helper function to escape HTML
   function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
   }

   // Update chat send button state based on input
   function updateChatSendButton() {
      const textarea = document.getElementById('userChatResponse');
      const sendButton = document.getElementById('chatSendButton');
      
      if (textarea && sendButton) {
         const hasContent = textarea.value.trim().length >= 5;
         sendButton.disabled = !hasContent;
         
         // Update button styling
         if (hasContent) {
            sendButton.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            sendButton.style.color = 'white';
            sendButton.style.opacity = '1';
         } else {
            sendButton.style.background = '#e9ecef';
            sendButton.style.color = '#adb5bd';
            sendButton.style.opacity = '0.6';
         }
      }
   }

   // Also add these helper functions for the chat response functionality
   function submitUserChatResponse() {
      const textarea = document.getElementById('userChatResponse');
      const userResponse = textarea.value.trim();

      if (userResponse.length < 5) {
         alert('Please enter a more substantial response');
         return;
      }

      // Check usage limits before processing
      checkAndResetDailyUsage();
      const dailyLimit = 10;
      if (!currentUser && usageState.dailyDiscussions >= dailyLimit) {
         showUpgradeModal();
         return;
      }

      // Increment usage counter for the AI response
      checkAndResetDailyUsage();
      usageState.dailyDiscussions++;
      saveUsageState();
      updateUsageDisplayAdvanced({
         userType: currentUser ? 'authenticated' : 'anonymous',
         isProUser: usageState.isProUser,
         remaining: currentUser ? 'unlimited' : Math.max(0, 10 - usageState.dailyDiscussions)
      });

      // Remove the entire chat container (input + controls)
      const chatContainer = document.querySelector('.chat-continuation-container');
      if (chatContainer) {
         chatContainer.remove();
      }

      // Add user response to chat
      const arena = document.getElementById('discussionArena');
      const userDiv = document.createElement('div');
      userDiv.className = 'speaker user-speaker';
      userDiv.innerHTML = `
        <div class="speaker-name">You</div>
        <div class="speaker-content"><p>${escapeHtml(userResponse)}</p></div>
    `;
      arena.appendChild(userDiv);

      // Clear the textarea
      textarea.value = '';
      
      // Get AI response and show input again after it's complete
      const chatParticipant = discussionState.participants[0];
      getChatContinuationResponse(arena, chatParticipant, userResponse).then(() => {
         // Show chat input again after AI responds
         showChatInputWithControls();
      });
   }

   function cancelUserResponse() {
      document.querySelector('.user-response-input').remove();
      showDiscussionControls();
   }

   async function getChatContinuationResponse(container, participant, userMessage) {
      const speakerDiv = document.createElement('div');
      speakerDiv.className = 'speaker';
      speakerDiv.innerHTML = `
        <div class="speaker-name">${participant.name}</div>
        <div><span class="loading"></span>Responding...</div>
    `;
      container.appendChild(speakerDiv);

      try {
         const prompt = `${participant.prompt}

You are continuing a personal conversation. The user just said: "${userMessage}"

Respond naturally and thoughtfully, staying true to your character. Keep the conversation engaging and ask a follow-up question if appropriate.

Respond in 120-150 words.`;

         const response = await callClaude(prompt);

         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div class="speaker-content">${formatResponse(response)}</div>
        `;
         assignSpeakerColor(speakerDiv, participant.name);

      } catch (error) {
         speakerDiv.innerHTML = `
            <div class="speaker-name">${participant.name}</div>
            <div class="speaker-content">❌ Error: ${error.message}</div>
        `;
      }
   }
console.log('Script reached the end successfully');

</script>
<script src="analytics-client.js"></script>
</body>
</html>