/*
 * âš ï¸ WARNING: DO NOT EDIT THIS FILE âš ï¸
 * 
 * This server.js file is DEPRECATED and not used in production.
 * 
 * The actual server file used by Vercel is: /server/server.js
 * 
 * All changes should be made to /server/server.js
 * 
 * This file is kept only for reference and may be removed in the future.
 */

require('dotenv').config();
const express = require('express');
const cors = require('cors');
const path = require('path');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const sqlite3 = require('sqlite3').verbose();

const app = express();

const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-here';
// Initialize Stripe
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

// Initialize SQLite Database
const dbPath = path.join(__dirname, 'brilliant_minds.db');
const db = new sqlite3.Database(dbPath);

// Create tables
db.serialize(() => {
    db.run(`
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            is_pro BOOLEAN DEFAULT FALSE,
            discussions_used INTEGER DEFAULT 0
        )
    `);
    
    db.run(`
        CREATE TABLE IF NOT EXISTS anonymous_users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ip_address TEXT UNIQUE NOT NULL,
            discussions_used INTEGER DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);
    
    console.log('Database initialized');
});

// Enable CORS and JSON parsing
app.use(cors());
app.use(express.json());
app.use(express.static('.')); // Serve static files from current directory

// Auth middleware
function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        return res.status(401).json({ error: 'Access token required' });
    }

    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({ error: 'Invalid token' });
        }
        req.user = user;
        next();
    });
}

// Optional auth middleware (allows both authenticated and guest users)
function optionalAuth(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token) {
        jwt.verify(token, JWT_SECRET, (err, user) => {
            if (!err) {
                req.user = user;
            }
        });
    }
    next();
}

// Helper function to get client IP address
function getClientIp(req) {
    return req.headers['x-forwarded-for'] || 
           req.headers['x-real-ip'] || 
           req.connection.remoteAddress || 
           req.socket.remoteAddress ||
           req.ip;
}

// ============================================================================
// AUTH ROUTES
// ============================================================================

// Register new user
app.post('/api/auth/register', async (req, res) => {
    try {
        const { email, password } = req.body;

        if (!email || !password) {
            return res.status(400).json({ error: 'Email and password required' });
        }

        if (password.length < 6) {
            return res.status(400).json({ error: 'Password must be at least 6 characters' });
        }

        // Hash password
        const passwordHash = await bcrypt.hash(password, 10);

        // Create user
        db.run('INSERT INTO users (email, password_hash) VALUES (?, ?)', 
               [email, passwordHash], function(err) {
            if (err) {
                if (err.code === 'SQLITE_CONSTRAINT') {
                    return res.status(400).json({ error: 'Email already exists' });
                }
                return res.status(500).json({ error: 'Failed to create user' });
            }

            // Create token
            const token = jwt.sign({ userId: this.lastID }, JWT_SECRET, { expiresIn: '30d' });
            
            res.json({
                token,
                user: {
                    id: this.lastID,
                    email,
                    isProUser: true, // TEMPORARILY SET TO TRUE FOR LOCAL TESTING
                    discussionsUsed: 0
                }
            });
        });
    } catch (error) {
        console.error('Register error:', error);
        res.status(500).json({ error: 'Server error' });
    }
});

// Login user
app.post('/api/auth/login', async (req, res) => {
    try {
        const { email, password } = req.body;

        if (!email || !password) {
            return res.status(400).json({ error: 'Email and password required' });
        }

        db.get('SELECT * FROM users WHERE email = ?', [email], async (err, user) => {
            if (err) {
                return res.status(500).json({ error: 'Server error' });
            }

            if (!user || !await bcrypt.compare(password, user.password_hash)) {
                return res.status(401).json({ error: 'Invalid email or password' });
            }

            const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '30d' });
            
            res.json({
                token,
                user: {
                    id: user.id,
                    email: user.email,
                    isProUser: true, // TEMPORARILY SET TO TRUE FOR LOCAL TESTING
                    discussionsUsed: user.discussions_used
                }
            });
        });
    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ error: 'Server error' });
    }
});

// Get current user info
app.get('/api/auth/me', authenticateToken, (req, res) => {
    db.get('SELECT * FROM users WHERE id = ?', [req.user.userId], (err, user) => {
        if (err || !user) {
            return res.status(404).json({ error: 'User not found' });
        }

        res.json({
            id: user.id,
            email: user.email,
            isProUser: true, // TEMPORARILY SET TO TRUE FOR LOCAL TESTING
            discussionsUsed: user.discussions_used
        });
    });
});

// ============================================================================
// EXISTING CLAUDE API (UPDATED WITH AUTH)
// ============================================================================

// API endpoint to proxy Claude requests (now with auth)
app.post('/api/claude', optionalAuth, async (req, res) => {
    try {
        const { message, figure, isSuggestion, discussionId } = req.body;
        const clientIp = getClientIp(req);
        
        console.log('API Request:', {
            isSuggestion,
            discussionId,
            clientIp,
            hasUser: !!req.user
        });
        
        // If this is just a suggestion request, skip usage tracking
        if (isSuggestion) {
            console.log('Skipping usage tracking - suggestion request');
            const claudeResponse = await makeClaudeRequest(message);
            return res.json(claudeResponse);
        }
        
        // Track discussion sessions
        if (!global.discussionSessions) {
            global.discussionSessions = new Map();
        }
        
        // Check if this is part of an existing discussion
        const isNewDiscussion = discussionId ? !global.discussionSessions.has(discussionId) : true;
        if (discussionId && isNewDiscussion) {
            global.discussionSessions.set(discussionId, {
                startTime: Date.now(),
                ip: clientIp,
                userId: req.user ? req.user.userId : null
            });
            
            // Clean up old sessions (older than 1 hour)
            const oneHourAgo = Date.now() - (60 * 60 * 1000);
            for (const [id, session] of global.discussionSessions) {
                if (session.startTime < oneHourAgo) {
                    global.discussionSessions.delete(id);
                }
            }
        }
        
        // Only count usage for NEW discussions
        // If no discussionId provided, always count (backward compatibility)
        // If discussionId provided, only count if it's new
        const shouldCountUsage = discussionId ? isNewDiscussion : true;
        
        console.log('Session tracking:', {
            discussionId,
            isNewDiscussion,
            shouldCountUsage,
            existingSessions: global.discussionSessions.size
        });
        
        // Check usage limits
        if (req.user) {
            // Authenticated user
            db.get('SELECT * FROM users WHERE id = ?', [req.user.userId], async (err, user) => {
                if (err) {
                    return res.status(500).json({ error: 'Database error' });
                }
                
                // Check if user has exceeded free limit (10 lifetime discussions)
                // TEMPORARILY DISABLED FOR LOCAL TESTING - All users treated as Pro
                /*
                if (!user.is_pro && user.discussions_used >= 10) {
                    return res.status(429).json({ 
                        error: 'Free discussion limit reached',
                        limit: true 
                    });
                }
                */
                
                // Make Claude API call
                const claudeResponse = await makeClaudeRequest(message);
                
                // Only increment usage counter for new discussions
                if (shouldCountUsage) {
                    db.run('UPDATE users SET discussions_used = discussions_used + 1 WHERE id = ?', 
                           [req.user.userId]);
                }
                
                res.json(claudeResponse);
            });
        } else {
            // Anonymous user - track by IP
            db.get('SELECT * FROM anonymous_users WHERE ip_address = ?', [clientIp], async (err, anonUser) => {
                if (err) {
                    return res.status(500).json({ error: 'Database error' });
                }
                
                // Check if anonymous user exists and has exceeded limit
                // TEMPORARILY DISABLED FOR LOCAL TESTING - All users treated as Pro
                /*
                if (anonUser && anonUser.discussions_used >= 3) {
                    return res.status(429).json({ 
                        error: 'Anonymous discussion limit reached',
                        limit: true,
                        guestLimitReached: true
                    });
                }
                */
                
                // Make Claude API call
                const claudeResponse = await makeClaudeRequest(message);
                
                // Only track usage for new discussions
                if (shouldCountUsage) {
                    if (anonUser) {
                        db.run('UPDATE anonymous_users SET discussions_used = discussions_used + 1 WHERE ip_address = ?', 
                               [clientIp]);
                    } else {
                        db.run('INSERT INTO anonymous_users (ip_address, discussions_used) VALUES (?, 1)', 
                               [clientIp]);
                    }
                }
                
                res.json(claudeResponse);
            });
        }
    } catch (error) {
        console.error('Server error:', error);
        res.status(500).json({ error: error.message });
    }
});

// Helper function to make Claude API request
async function makeClaudeRequest(message) {
    console.log('Making Claude API request');
    console.log('API Key exists:', !!CLAUDE_API_KEY);
    console.log('API Key length:', CLAUDE_API_KEY ? CLAUDE_API_KEY.length : 0);
    
    const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'x-api-key': CLAUDE_API_KEY,
            'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 1200,
            messages: [{
                role: 'user',
                content: message
            }]
        })
    });
    
    if (!response.ok) {
        const errorText = await response.text();
        console.error('Claude API Error:', response.status, errorText);
        
        // Parse error for better debugging
        try {
            const errorJson = JSON.parse(errorText);
            console.error('Error details:', errorJson);
            
            if (errorJson.error && errorJson.error.type === 'insufficient_balance') {
                console.error('âŒ API KEY IS OUT OF CREDITS!');
                throw new Error('API key is out of credits. Please add credits to your Anthropic account.');
            }
        } catch (e) {
            // If error text isn't JSON, just log it
        }
        
        throw new Error(errorText);
    }
    
    return await response.json();
}

// ============================================================================
// YOUR EXISTING STRIPE CODE (UNCHANGED)
// ============================================================================

app.post('/api/create-checkout-session', async (req, res) => {
    try {
        const { priceId } = req.body;
        
        console.log('Creating checkout session for price:', priceId);
        
        // DEBUG: Log all the header info
        console.log('ðŸ” Request headers:', {
            origin: req.headers.origin,
            referer: req.headers.referer,
            host: req.headers.host
        });
        
        // Try multiple ways to get the correct URL
        let baseUrl;
        if (req.headers.origin) {
            baseUrl = req.headers.origin;
        } else if (req.headers.referer) {
            baseUrl = req.headers.referer.replace(/\/$/, ''); // Remove trailing slash
        } else {
            baseUrl = 'https://brilliant-minds-clean.vercel.app/';
        }
        
        console.log('ðŸŽ¯ Using baseUrl:', baseUrl);
        console.log('ðŸŽ¯ Success URL will be:', `${baseUrl}?success=true`);
        
        const session = await stripe.checkout.sessions.create({
            mode: 'subscription',
            payment_method_types: ['card'],
            line_items: [
                {
                    price: priceId,
                    quantity: 1,
                },
            ],
            success_url: `${baseUrl}?success=true`,
            cancel_url: `${baseUrl}?canceled=true`,
        });

        res.json({ sessionId: session.id });
    } catch (error) {
        console.error('Error creating checkout session:', error);
        res.status(500).json({ error: 'Failed to create checkout session' });
    }
});

// ============================================================================
// YOUR EXISTING ANALYTICS CODE (UNCHANGED)
// ============================================================================

// Enhanced analytics endpoint with storage
app.post('/api/analytics', async (req, res) => {
    try {
        const event = req.body;
        
        // Log the analytics event
        console.log('ðŸ“Š Analytics Event:', {
            eventType: event.eventType,
            userId: event.userId,
            timestamp: event.timestamp,
            data: event.data
        });
        
        // Store analytics in memory (simple aggregation)
        if (!global.analyticsData) {
            global.analyticsData = {
                totalEvents: 0,
                dailyStats: {},
                formatPopularity: {},
                userSessions: {},
                conversions: {
                    totalUpgrades: 0,
                    upgradesByDay: {}
                }
            };
        }
        
        const analytics = global.analyticsData;
        const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
        
        // Update global counters
        analytics.totalEvents++;
        
        // Initialize today's stats if needed
        if (!analytics.dailyStats[today]) {
            analytics.dailyStats[today] = {
                sessions: new Set(),
                discussions: 0,
                formatUsage: {},
                upgrades: 0
            };
        }
        
        // Process different event types
        switch (event.eventType) {
            case 'session_start':
                analytics.dailyStats[today].sessions.add(event.userId);
                if (!analytics.userSessions[event.userId]) {
                    analytics.userSessions[event.userId] = {
                        firstSession: event.timestamp,
                        totalSessions: 0,
                        totalDiscussions: 0,
                        isProUser: false
                    };
                }
                analytics.userSessions[event.userId].totalSessions++;
                break;
                
            case 'discussion_start':
                analytics.dailyStats[today].discussions++;
                const format = event.data.format;
                analytics.dailyStats[today].formatUsage[format] = 
                    (analytics.dailyStats[today].formatUsage[format] || 0) + 1;
                analytics.formatPopularity[format] = 
                    (analytics.formatPopularity[format] || 0) + 1;
                    
                if (analytics.userSessions[event.userId]) {
                    analytics.userSessions[event.userId].totalDiscussions++;
                }
                break;
                
            case 'user_upgraded':
                analytics.conversions.totalUpgrades++;
                analytics.conversions.upgradesByDay[today] = 
                    (analytics.conversions.upgradesByDay[today] || 0) + 1;
                analytics.dailyStats[today].upgrades++;
                
                if (analytics.userSessions[event.userId]) {
                    analytics.userSessions[event.userId].isProUser = true;
                }
                break;
        }
        
        res.json({ success: true, received: event.eventType });
        
    } catch (error) {
        console.error('Analytics error:', error);
        res.status(500).json({ error: 'Failed to process analytics' });
    }
});

// Add analytics dashboard endpoint
app.get('/api/analytics/dashboard', (req, res) => {
    try {
        if (!global.analyticsData) {
            return res.json({ message: 'No analytics data yet' });
        }
        
        const analytics = global.analyticsData;
        const today = new Date().toISOString().split('T')[0];
        
        // Convert Sets to counts for JSON response
        const processedDailyStats = {};
        Object.keys(analytics.dailyStats).forEach(date => {
            processedDailyStats[date] = {
                ...analytics.dailyStats[date],
                sessions: analytics.dailyStats[date].sessions.size
            };
        });
        
        const dashboard = {
            overview: {
                totalEvents: analytics.totalEvents,
                totalUpgrades: analytics.conversions.totalUpgrades,
                totalUsers: Object.keys(analytics.userSessions).length,
                todaysSessions: analytics.dailyStats[today]?.sessions.size || 0,
                todaysDiscussions: analytics.dailyStats[today]?.discussions || 0
            },
            formatPopularity: analytics.formatPopularity,
            dailyStats: processedDailyStats,
            recentUpgrades: analytics.conversions.upgradesByDay
        };
        
        res.json(dashboard);
        
    } catch (error) {
        console.error('Dashboard error:', error);
        res.status(500).json({ error: 'Failed to get dashboard data' });
    }
});

// ============================================================================
// YOUR EXISTING ROUTES (UNCHANGED)
// ============================================================================

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

app.get('/chat.html', (req, res) => {
    res.sendFile(path.join(__dirname, 'chat.html'));
});

// Health check endpoint
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'ok', 
        timestamp: new Date().toISOString(),
        hasApiKey: !!CLAUDE_API_KEY
    });
});

// Test Claude API endpoint
app.get('/api/test-claude', async (req, res) => {
    try {
        console.log('Testing Claude API...');
        const response = await makeClaudeRequest('Say "API is working!" in exactly 3 words.');
        res.json({ 
            success: true, 
            response: response,
            message: 'Claude API is working correctly!'
        });
    } catch (error) {
        console.error('Claude API test failed:', error.message);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            message: 'Claude API test failed. Check server logs for details.'
        });
    }
});

// Export the app for Vercel (remove the app.listen for serverless)
module.exports = app;

// Only listen when running locally (not on Vercel)
if (require.main === module) {
    const PORT = process.env.PORT || 3000;
    app.listen(PORT, () => {
        console.log(`Server running on port ${PORT}`);
        console.log(`Open your app at: http://localhost:${PORT}`);
    });
}